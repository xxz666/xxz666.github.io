{"pages":[{"title":"about me","text":"","link":"/about/index.html"}],"posts":[{"title":"关于python的一些学习","text":"注：首先声明，在这文章只是平时的学习笔记，用于加深记忆以及以后方便查找的功能。 1.一些基本的常识python的一些基本语法结构要比c++简单的多，而且写起来很方便，没有像c++那么多的限制，有了一些c++的基础学起来相对容易一些： 关于编译器 ，如果不进行大型的项目，直接创建一个py结尾的文件即可编写python代码，如果运行一些比较大的项目，应该需要下载pychram，这个编译器用起来方便一些，应该需要花钱，但是网上也有一些破解版和汉化的软件，很简单就可以查找到； 和以前学的c++的差别，用了几天感觉差别还是有一些，但是不得不说python是比较方便的软件，而且相比c++代码量比较少，只举一个例子，比如说创建一个函数： 用python 12345678910def func(n): if n==1: return 1 elif n==2: return 1 else: return func(n-1)+func(n-2)n=int(input('请输入一个数; '))result=func(n)print('%d 的斐波那契函数为 %d' %(n,result)) 用c++ 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int func(int i){ if(i==1||i==2) { return 1; } else { return func(i-1)+func(i-2); }};int main(){ int i,result; cout&lt;&lt;\"请输入一个数: \"; cin&gt;&gt;i; result=func(i); cout&lt;&lt; i &lt;&lt;\"的斐波那契函数为：\"&lt;&lt;result&lt;&lt;endl; return 0;} 结果很显然，同样是用递归实现一个斐波那契函数，代码量还是差很多的，关于函数和类的封装继承和多态区别还是有的，但是不大，接下来介绍一个python非常适用的领域爬虫。 2.模拟有道词典实现单词的翻译（爬虫）12345678910111213141516171819202122232425import urllib.requestimport urllib.parseimport json #轻量级的数据交换模式num=input('请输入要翻译的内容：')url='http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule'data={}data['i']= numdata['from']= 'AUTO'data['to']='AUTO'data['smartresult']= 'dict'data['client']= 'fanyideskweb'data['salt']= '15727641027462'data['sign']= '13305999ab8cf444f7ddbc11b62baffd'data['ts']= '1572764102746'data['bv']= '7d4ac98e0e04505e57a74dd5992cc541'data['doctype']= 'json'data['version']= '2.1'data['keyfrom']= 'fanyi.web'data['action']= 'FY_BY_CLICKBUTTION'data=urllib.parse.urlencode(data).encode('utf-8')response=urllib.request.urlopen(url,data)html=response.read().decode('utf-8')a=json.loads(html)b=a['translateResult'][0][0]['tgt']print('翻译结果为: %s' %b) 其中 url='http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule'表示所爬取的链接地址，data 代表了一个字典，存放了各种数据。这些都是从有道的网页后台所爬取的。最后根据你输入的内容即可翻译出相应的结果。 连载中，还在学习中。。。","link":"/2019/11/09/%E5%85%B3%E4%BA%8Epython%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/"},{"title":"关于张量互补问题的光滑牛顿法","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找。 关于张量互补问题的一个算法优化前些日子在看一个非光滑牛顿算法解决张量互补问题的论文时，有一点想法并跟导师说了一下，老师说思路可行，但是问题比较小不能表好的论文，但是还是总结到这里吧，万一毕业论文用到呢。 以下是我的思路（注：在上一篇文章会一直更新关于张量互补问题的基本内容，所以关于张量互补问题在这篇文章就不介绍了）： 那篇论文提出的是张量互补问题与一个张量方程组是等价的，也就是下边的内容：A vector $|x|+x \\in R^n$ is a solution of the TCP$(\\mathscr{A},q)$ if and only if the vector $x \\in R^n$ is a solution of the following system of equations:$$|x|-x=\\mathscr{A}(|x|+x)^{m-1}+q$$where $|x|=(|x_1|,|x_2|,\\cdots,|x_n|)^{\\top} \\in R^n$.也就是说$$|x|+x \\geq 0,\\mathscr{A} (|x|+x)^{m-1}+q \\geq 0,\\text { and } (|x|+x)^{\\top}( \\mathscr{A}(|x|+x)^{m-1}+q)= 0$$等价于$$|x|-x=\\mathscr{A}(|x|+x)^{m-1}+q.$$ 关于我的优化思路该论文中所提到的是非光滑牛顿算法，原因很简单有 $|x|$ 的存在，算法不可能是光滑的，但是如果我用光滑逼近函数去逼近 $|x|$，那么可以得到光滑牛顿算法同样可以解决这个问题，关于光滑牛顿法要比非光滑牛顿法好太多，有了思路我也尝试着用 MATLAB 对这个算法进行了编写。 程序的设计1.要解决的问题刚才所提到的方程，光滑以后为$$f(\\mu, x):=2x-2\\Psi(\\mu, x)+\\mathscr{A}(2\\Psi(\\mu, x))^{m-1}+q=0.$$其中$$|x|=2\\Psi(\\mu, x)-x:=2\\left(\\begin{array}{c}{\\psi\\left(\\mu, x_{1}\\right)} \\ {\\vdots} \\ {\\psi\\left(\\mu, x_{n}\\right)}\\end{array}\\right)-x,$$$$ \\psi(\\mu, x)=\\mu\\ln(1+e^{\\frac{x}{\\mu}}).$$ 2.算法的流程A Modulus-Based Smoothing Newton Algorithm Step $\\textbf{0}$ Choose $\\sigma \\in(0,1)$, $\\mu &gt;0$ is a sufficient small positive number, $x^{0} \\in R^{n}$. Set $k:=0$.Step $\\textbf{1}$ If $H\\left(x^{k}\\right)=0$, stop. Otherwise, go to Step 2.Step $\\textbf{2}$ Compute $\\Delta x^{k} \\in R^{n}$ by$$f\\left(\\mu,x^{k}\\right)+ f’_x\\left(\\mu,x^{k}\\right) \\Delta x^{k}=0.$$Step $\\textbf{3}$ Let $i_k$ be the minimum of the values $0, 1, 2, \\cdots$ such that$$H\\left(x^{k}+2^{-i_k} \\Delta x^{k}\\right) \\leq H(x^k)+ \\sigma2^{-i_k}\\bigtriangledown H(x^k)^{\\top}\\Delta x^{k}.$$Step $\\textbf{4}$ Set $x^{k+1}:=x^{k}+2^{-i_k} \\Delta x^{k}$ and $k:=k+1.$ Go to Step 1. 3.程序设计以下是我用 MATLAB 做的数值实验的代码：Initialization.m 1234567891011121314151617181920rand('state',0); %&lt;-- Setup for the scriptsubs = [1,1,1,1;2,2,2,2;1,2,2,2;1,1,2,2;2,1,1,1;2,2,1,1]; %&lt;-- Subscripts of the nonzeros.vals = [1;1;-1;1;-1;1];A= sptensor(subs,vals);%离散张量的初始化m=3;n=size(A,1); %A的第一阶的维数%q=randn([n,1]);q=[1;2];Miu_0=0.01; %Choose Miubara &gt;0Delta=0.4; %Choose Delta between (0,1)Sigma=0.3; %Choose Sigma between (0,1/2)x_0=randn([n,1]);z_0=[Miu_0;x_0];HH=H(z_0,A,q,n);norm_0=0.5*norm(HH)^2;k=0;z_k=z_0;Miu_k=Miu_0;x_k=x_0;norm_k=norm_0; smoothing.m 1234567891011121314151617181920212223fprintf('当张量为4阶2维时：\\n');fprintf('当初始向量x_0=(%6.4f , %6.4f),迭代过程为：\\n',x_0); %example 1fprintf('当方程中初始的 q=(%6.4f , %6.4f),迭代过程为：\\n',q);fprintf(' k norm(H(z_k)) Miu_k x_k\\n');tstart = tic; % 计时器，表示计时开始while (norm_k &gt; 1.0e-9) % 终止条件的验证 if rcond(dH(z_k,A,m,n))&gt;1.0e-10; % 确认雅克比矩阵的可逆性 dx_k=(dH(z_k,A,m,n))\\(-HH); %HH 为H dz_k=[0;dx_k]; alpha_k=Alpha(z_k,dz_k,dx_k,Sigma,A,q,m,n); %运行Alpha文件中的函数 x_k = x_k + alpha_k.* dx_k; Miu_k=Miu_0; z_k=[Miu_0;x_k]; k=k+1; HH=H(z_k,A,q,n); norm_k=0.5*norm(HH)^2; fprintf('%4d %10.2d %6.4f (%6.4f , %6.4f)\\n',k, norm_k,Miu_k, x_k);% %10.2d 数的宽度为10，小数点后2位 end;endtelapsed = toc(tstart); %表示终止计时器fprintf('经过 %d 次迭代满足条件,最后各项输出结果为：\\n',k);fprintf(' k x_0 x_k s_k Times norm(H(z_k)) q \\n');fprintf('%4d (%6.4f , %6.4f) (%6.4f , %6.4f) (%6.4f , %6.4f) %6.4f %6.2d (%6.4f , %6.4f)\\n',k,x_0,x_k,s_k,telapsed,norm_k,q); Alpha.m 1234567891011121314function val = Alpha(z_k,dz_k,dx_k,Sigma,A,q,m,n)FLAG = 1;check = 1;while (FLAG) con1=norm(H(z_k+(2^(-check)).*dz_k,A,q,n))^2; %不等式的左边 con2=norm(H(z_k,A,q,n))^2+Sigma*2^(-check)* ((dH(z_k,A,m,n))'*H(z_k,A,q,n))'*dx_k; %不等式的右边 if (con1 &lt;= con2) val = 2^(-check); return; else check = check+1; endendend H.m 12345678910function val =H(z_k,A,q,n)Miu_k=z_k(1);%μ_k 为 z_k 的第一行x_k=z_k(2:n+1); %x_k 为 z_k 的第2行到第n+1行e_k=2*x_k-2*Miu_k*log(1+exp(x_k./Miu_k));c_k=2*Miu_k*log(1+exp(x_k./Miu_k));dd=ttv(A,{c_k,c_k,c_k},[2 3 4]); yk1=double(dd); %转化为小数格式H=e_k+yk1+q;val=H;end dH.m 12345678910111213function val = dH(z_k,A,m,n)Miu_k=z_k(1); %μ_k 为 z_k 的第一行x_k=z_k(2:n+1); %x_k 为 z_k的第二到第n+1行I=eye(n);c_k=2*Miu_k*log(1+exp(x_k/Miu_k));d_k=exp(x_k./Miu_k);e_k=(1+exp(x_k./Miu_k));df3=diag(d_k./e_k);df1=(m-1)*ttv(A,{c_k,c_k}, [3 4] );df11=double(df1);dH=2*I-2*(df3)+df11*2*((df3));val=dH;end 以上就是所有内容，最后得到的结果和论文中的算法一致，所以我的思路应该是正确的。","link":"/2019/10/28/%E5%85%B3%E4%BA%8E%E5%BC%A0%E9%87%8F%E4%BA%92%E8%A1%A5%E9%97%AE%E9%A2%98%E7%9A%84%E5%85%89%E6%BB%91%E7%89%9B%E9%A1%BF%E6%B3%95/"},{"title":"关于 x 绝对值的光滑函数","text":"首先声明，文章只是平时的学习笔记，用于加深记忆以及以后方便查找的功能。 1、关于 $|x|$ 的第一个光滑函数定义一个函数 $\\phi: R^2 \\rightarrow R$ 满足$$\\phi(\\mu,x)=\\sqrt{\\mu^{2}+x^{2}}$$ 3.csdcsd3.csdcsd3.csdcsd 由于 $|x|$ 本身是不光滑的，但是对于 $\\phi(\\mu,x)$ 来说，该函数在 $(\\mu, x) \\in {R_{++}\\times R}$ 是连续可微的，并且满足对于任给的 $x \\in R$ 有 $\\lim \\limits _{\\mu \\rightarrow 0} \\phi(\\mu, x)=|x|$ 成立，从而我们可以利用 $\\phi(\\mu,x)$ 来把 $|x|$ 光滑化，那么原来的 $|x|$ 是不可求导的变成了可求导 $\\phi(\\mu,x)$，就会有很多良好的性质。 2、关于 $|x|$ 的第二个光滑函数这种处理办法比较巧妙，我们知道$$\\max{x,0}=\\frac{|x|+x}{2}$$通过解这个方程我们可以得到$$|x|=2\\max{x,0}-x$$对于 $\\max{x,0}$ 我们可以选取它的光滑逼近函数$\\psi(\\mu,x) : R^2 \\rightarrow R$$$\\psi(\\mu, x)=\\mu\\ln(1+e^{\\frac{x}{\\mu}})$$对于这个函数的构造很好理解，只要 $\\mu$ 足够小以至于 $1+e^{\\frac{x}{\\mu}}$ 可以近似的等于 $e^{\\frac{x}{\\mu}}$ 那么 $$\\psi(\\mu, x)=|x|$$可以利用以下的 matlab 代码去实现该函数 $\\psi(\\mu,x)$ 1234x=input(&apos;请输入 x=&apos;);a=0.01; %不能取太小, 否则exp(1/a)会很大，导致MATLAB无法显示f=a*log(1+exp(x/a));fprintf(&apos;0 与 %6.4d 的最大者为:%6.4d\\n&apos;,x,f); 做好的最大值的光滑逼近，那么$$|x|=2\\max{x,0}-x=2\\psi(\\mu,x)-x=2\\mu\\ln(1+e^{\\frac{x}{\\mu}})-x$$其中 $\\mu$ 为一个任意小的正实数。 1.csdcsd通过以上的两种方式可以对 $|x|$ 进行光滑化，对于一些方程的求解是很有帮助的。","link":"/2019/10/29/%E5%85%B3%E4%BA%8Ex%E7%BB%9D%E5%AF%B9%E5%80%BC%E7%9A%84%E5%85%89%E6%BB%91%E5%87%BD%E6%95%B0/"},{"title":"在测试vf","text":"关于该博客的说明 该博客是2019年10月份搭建，并托管于GitHub。该博客仅用于个人学习使用，我会将学习中解决的问题发到这里，可能会借鉴其他大佬的解决方案，但是我保证仅用于个人学习使用。为何使用自己搭建的博客，而不使用一些像csdn那些博客？我感觉通过搭建博客的过程学习到了很多知识，不仅可以写博客，还可以了解到一些底层的知识（包括整个搭建过程、主题的配置与改进），何乐而不为？","link":"/2020/01/28/%E5%9C%A8%E6%B5%8B%E8%AF%95vf/"},{"title":"张量互补问题总结","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找。 关于张量互补问题简单介绍张量互补问题所含内容1.张量互补问题的基础知识2.张量互补问题的算法总结3.张量互补问题的应用总结","link":"/2019/10/27/%E5%BC%A0%E9%87%8F%E4%BA%92%E8%A1%A5%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"我的第一篇博客","text":"折腾了一天，终于成功了！！！","link":"/2019/10/26/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"},{"title":"时间变换凸优化程序","text":"","link":"/2019/12/22/%E6%97%B6%E9%97%B4%E5%8F%98%E6%8D%A2%E5%87%B8%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F/"},{"title":"爬取QQ群成员的信息","text":"","link":"/2019/11/19/%E7%88%AC%E5%8F%96QQ%E7%BE%A4%E6%88%90%E5%91%98%E7%9A%84%E4%BF%A1%E6%81%AF/"}],"tags":[{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"最优化算法","slug":"最优化算法","link":"/tags/%E6%9C%80%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"},{"name":"张量互补问题","slug":"张量互补问题","link":"/tags/%E5%BC%A0%E9%87%8F%E4%BA%92%E8%A1%A5%E9%97%AE%E9%A2%98/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"张量互补问题","slug":"张量互补问题","link":"/categories/%E5%BC%A0%E9%87%8F%E4%BA%92%E8%A1%A5%E9%97%AE%E9%A2%98/"}]}