{"pages":[{"title":"about me","text":"","link":"/about/index.html"}],"posts":[{"title":"2019的小小总结","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找。 过去的一年很充实，在研一下学期完成了研究生的所有课程（学习了：泛函分析，抽象代数，调和分析，同调拓扑，同调代数，流行微积分，还有英语和政治），研究生的课程是真的难，本来本科对数学还是有一定兴趣的，但是上了研究生的课就完全没有兴趣了，在上半年除了完成一些课程之外，还学习了一些编程语言，包括： Matlab（写论文要用到），还正式接触了 c++ ,运营了自己的考研公众号，为考研学生推送考研新闻，总体来说很充实，做的不好的地方就是由于对专业课没有兴趣，所以就没有好好学。暑假本来是要回家的，但是老师给推荐了高数辅导的兼职，就在学校度过了两个月，在学校期间除了完成高数的兼职，还初步接触了机器学习方面的书籍，听了黑马程序员的 c++ 教程， 暑假虽然很热，但是也很快乐。研二的上学期开始了，正式开始读文献准备写文章，由于研一第一学期看了不少文章，所以刚开学就确定了论文的内容，经过两个月的修改，最终完成了投稿，除此之外在10月底学会了用 hexo 搭建个人博客，并学习了大话数据结构，初步接触了Python，完成了时间变换凸优化的计算编程部分，由于没有课，所以下学期过得有点拖节奏，有的任务并没有完成，只能拖到寒假来完成了，本来想把 essential c++ 和 c++ primer 看一下，但是没有时间了。","link":"/2019/12/31/2019%E7%9A%84%E5%B0%8F%E5%B0%8F%E6%80%BB%E7%BB%93/"},{"title":"c++primer的学习笔记1-2","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找，只记录自己不会或者需要补充的内容。 第一章 开始 前缀递增运算符 ++a ,先给 a 增加，再用 a。 读取数量不定的数据用 while, 并注意输入文件以 Ctrl+z 结尾。 for循环与while循环的优缺点：当循环次数已知用for，循环次数未知用while 第二章 变量和基本类型 算数类型除了哪几种基本的类型分类以外，还有有符号和无符号的分类，无符号用unsigned，无符号只能表示大于等于0的数，但是带符号的可以大于小于等于0。 关于标识符，c++的标识符只能由字母、数字、下划线组成，并且不能以数字开头。 关于复合类型，引用的作用是给对象起别名，且引用必须要初始化（必须是对象），但一个引用不能同时给两个对象起别名。指针本身就是一个对象，并且无需在定义的时候初始化。 关于void* 与其他的指针类似，但是改地址中到底是什么类型的对象，并不能确定。 指针与引用的区别：指针指向了某个对象，引用绑定了某个对象；指针本身就是一个对象，引用相当于给对象起别名；指针无需初始化，但引用必须初始化。 顶层const表示指针本身是一个常量，底层const表示指针所指的对象是常量。 类型的别名：typedef a b;b是a的别名。或者 using b=a; auto可以让编译器通过初始值来推算变量的类型；decltype是希望从某个表达式中推断出变量类型，但是并不想用该表达式作为初值decltype(a) b=c(想用a的类型，但是给初值为c)。经典习题 10 以下变量的初值是多少？1234567string a;//默认初始化为空串int b;//默认初始化为0int main(){ string c;//默认初始化为空串 int d;//不被初始化，称为一个奇异值}","link":"/2020/04/12/c-primer%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-2/"},{"title":"c++primer的学习笔记10","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找，只记录自己不会或者需要补充的内容。 第十章 泛型算法 求和的函数accumulate(v.begin(),v.end(),0)初始值为0，v的所有元素的和。 求相等的函数equal(v1.begin(),v1.end(),v2.begin())。 仿函数就是在类中重载operator()，谓词就是bool类型的函数或者仿函数（根据参数的个数分为一元谓词和二元谓词）。 关于lambda函数，没有名字的函数比如：sum=[ ] (int a,int b){return a+b;},调用sum(2,3)","link":"/2020/05/13/c-primer%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010/"},{"title":"c++primer的学习笔记3","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找，只记录自己不会或者需要补充的内容。 第三章 字符串 向量和数组 关于初始化string对象，用等号初始化称为拷贝初始化，不使用等号的为直接初始化。 关于getline读取一整行（与输入运算符相比，getline读取中间的空白符），getline(cin,s),只要遇到换行符就停止。关于s.empty()判断字符串是否为空，s.size()输出对象的长度 处理string中的字符，在cctype头文件中，常用的几个函数，比如：tolower()把字母都改成小写，toupper()把字母都改成大写。 在c++11中关于范围for循环新增了12for(auto c:str)//c遍历str中的每一个字符,如果想改变字符串的内容，则用 &amp;c（目的相当于起别名） cout&lt;&lt;c&lt;&lt;endl; 检验字符是否为标点符号的函数为ispunct()。 统计各个分数段的人数：++score[grade/10] char类型的初始化最后默认添加了‘\\0’，所以应当给他留出一个位置。经典习题 5 读取多个字符串并连在一起，输出长的字符串。字符串中间加空格，并输出长的字符串。 123456789101112131415161718192021222324int main(){ vector&lt;string&gt; vst; string str; string result; char c='y'; cout&lt;&lt;\"请输入字符串：\"; while(cin&gt;&gt;str) { result=result+str+' ';//result+=str; cout&lt;&lt;\"你是否还继续输入：y或者n \"; cin&gt;&gt;c; if(c=='y') { cout&lt;&lt;\"请再次输入字符串：\"; } else { break; } } cout&lt;&lt;result&lt;&lt;endl; system(\"pause\");} 3.17 读取一组词并存放在vector容器中，把每个词改成大写，每个词占一行并输出结果。 1234567891011121314151617181920212223242526272829303132333435int main(){ vector&lt;string&gt; vst; string str; char c='y'; cout&lt;&lt;\"请输入字符串：\"; while(cin&gt;&gt;str) { vst.push_back(str); cout&lt;&lt;\"你是否还继续输入：y或者n \"; cin&gt;&gt;c; if(c=='y') { cout&lt;&lt;\"请再次输入字符串：\"; } else { break; } } for(int j=0;j&lt;vst.size();j++)//vc不支持c++11所以没用auto { for(int it=0;vst[j][it];it++) { vst[j][it]=toupper(vst[j][it]); } } for(int k=0;k&lt;vst.size();k++) { cout&lt;&lt;vst[k]&lt;&lt;\" \"; } cout&lt;&lt;endl; system(\"pause\");} 3.20 读取一组整数并存入到vector，把相邻两项和首位两项的和输出。 12345678910111213141516171819202122232425262728293031int main(){ vector&lt;int&gt; vst; int str; cout&lt;&lt;\"请输入一组整数，中间空格隔开：\"; while(cin&gt;&gt;str) { vst.push_back(str); } cout&lt;&lt;endl; cout&lt;&lt;\"相邻两个数相加为：\"; for(int i=0;i&lt;vst.size()-1;i+=2) { cout&lt;&lt;vst[i]+vst[i+1]&lt;&lt;\" \"; } cout&lt;&lt;endl; if(vst.size()%2!=0) { cout&lt;&lt;\"数组为奇数个，输出最后一个数为：\"&lt;&lt;vst[vst.size()-1]&lt;&lt;endl; } cout&lt;&lt;\"首位两个数相加为：\"; for(int j=0;j&lt;vst.size()/2;j++) { cout&lt;&lt;vst[j]+vst[vst.size()-1-j]&lt;&lt;\" \"; } if(vst.size()%2!=0) { cout&lt;&lt;\"数组为奇数个，输出中间的数为:\"&lt;&lt;vst[vst.size()/2]&lt;&lt;endl; } system(\"pause\");}","link":"/2020/04/15/c-primer%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"},{"title":"c++primer的学习笔记6","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找，只记录自己不会或者需要补充的内容。 第六章 函数 如果函数无需改变引用形参的值，将其声明为常量形参。（在某些地方应该用常量形参，而用了普通的引用形参，则会发生让使用者误认为可以修改，或者没有办法把其他类型的实参传入该参数列表） 1234int size_s(const string &amp;s){ return s.size();//在这个返回值中并没有变化s的值，用常量形参} 一般的函数只能返回一个，当返回值较多的时候，可以把要返回的参数放到形参列表 12345678910111213141516171819202122232425int time(const string &amp;s, char c,int &amp;a)//a表示一共出现的次数{//s为了避免拷贝，用引用，而且并没有改变s所以常量，在主函数中c并没有给函数外部，//a需要反馈给函数外部，并且时变化的 int b=0;//第一次出现的位置 for(int i=0;i&lt;s.size();i++) { if(s[i]==c) { if(b==0)//这个地方巧妙，只要b变化一次，就再也不执行该语句了 { b=i+1; } a++; } } return b;} int main(){ string s=\"adsdasdaaa\"; int a=0; int b=time(s,'a',a); cout&lt;&lt;\"第一次出现的位置为：\"&lt;&lt;b&lt;&lt;\" 一共出现了：\"&lt;&lt;a&lt;&lt;\" 次\"&lt;&lt;endl; return 0;} 关于数组的形参， int func(const int (*a)[]) 或者 int func(const int (&amp;a)[]). 在主函数中加入形参，int main(int c,char **b)，其中b为字符串，c为所含的个数。 函数的重载，当函数名相同，但是函数的参数列表不同（参数个数不同，参数类型不同）。需要注意的是函数只有返回值类型不同，不能发生重载。并且有const也不能发生重载。 关于默认实参，从某个参数开始默认实参，到末尾都必须有默认参数。int func(int a,int b=1,int c=3) 关于内联函数，在函数前面加一个inline则可以直接运行内部的函数把它展开，内联函数可以多次定义但须保证函数的定义完全相同，所以为了方便经常放到头文件中。 关于constexpr的使用，需要保证函数的形参类型和函数的返回值类型都是字面值类型。 12345constexpr int func()//形参列表{ return 2;//返回值}constexpr int a=func();//可以用同类型的来接收 关于函数的匹配，首先保证函数的名字相同，齐次保证函数给出的实参与函数的形参数量以及函数的类型是否相同，如果都不同，再检查函数是否能发生类型转换，需要注意一定要选取最佳的匹配方式。 6.33 用递归函数写一个返回所有vector对象的元素 123456789101112131415161718void func(vector&lt;int&gt; v1,int z){ if(z&gt;0) { func(v1,z-1); cout&lt;&lt;v1[z-1]&lt;&lt;endl; }}int main(){ vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(4); func(v,v.size()); return 0;} 6.39 关于函数实参的问题 12int func(int a,int b);int func(const int a,const int b);//本意为声明函数并把整形常量做为实参，但是该const并不影响传入函数的对象，所以两个函数并没有区别，并不能发生重载。","link":"/2020/04/29/c-primer%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06/"},{"title":"c++primer的学习笔记4-5","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找，只记录自己不会或者需要补充的内容。 第四章 表达式 逻辑与两个运算对象都为真时，才为真，并且左边运算对象为真时，才计算右侧对象。逻辑或两个运算对象一个为真时，为真。并且左侧运算对象为假时，才计算右侧对象。 逗号运算符，形式为 表达式，表达式，表达式，返回的值为最后一个表达式的结果，并且中间有公用的变量可以在每个表达式中用，例val=(j++,j+=50,j+100),val=j+1+50+100。 隐式类型转换，是在做运算的时候程序会根据不同的类型自动转换成需要的结果。 4.9 下面程序的计算过程是什么样的？ 12char *p=\"Hello World\";if(p&amp;&amp;*p)//表示先检查首地址是否为空，非空继续检查首地址所指向的值是否为空 4.32 解释循环语句的含义 1234const int size=5;int a[size]={1,2,3,4,5};for(int *p=ia,i=0;i!=size&amp;&amp;p!=ia+size;i++,p++)//指针p指向首元素，定义整形变量i为0，第二部分为终止条件，第三部分都加一 4.33 说明下面表达式的含义 12表达式 ? ++x,++y:--x,--y;//一般会认为表达式成立xy分别加1，不成立分别减1//但是计算顺序为 (表达式 ? ++x,++y:--x),--y;即表达式成立xy加1且y-1,表达式不成立xy减1","link":"/2020/04/24/c-primer%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-5/"},{"title":"essential c++ 学习--之c++编程基础","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找。由于已经总结了一些视频中的内容，所以只做补充，把不熟悉的内容加进来。 c++编程基础1 关于 using namespace std; 使用标准命名空间。std 为标准库的命名空间的总称，命名空间是一种把库名称封装起来的方法，可以防止在程序中多个实体具有相同的名称，导致程序不能区别（比如程序中多个 cout）。2 关于对象的初始化，一般方法为int a=3; 也可以使用内置的构造函数进行初始化int a(3) 这种方法主要应用于复数的初始化： 12#include&lt;complex&gt;complex&lt;double&gt; ca(1,7);//初始化为 1+7i 3 非常好用的表达式 判断句 ？ 表达式A ：表达式 B 该判断句如果为真，则执行表达式A，否则执行表达式B。前置递增 ++a 先增后用，后置递增 a++先用后增。4 各种条件语句和循环语句的表达式 1234567switch(A)//非常实用的 switch 但是经常忘记使用{ case 1: case 2: case 3: default:} 5 关于 Array 与 vector 提倡使用 vector 容器，但是平时基本上都在用 Array 12345678910int a[5]={1,2,3,4,5};//Array 的初始化#include&lt;vector&gt;vector&lt;int&gt; a1;a1.push_back(1);a1.push_back(2);a1.push_back(3);a1.push_back(4);a1.push_back(5);//vector 容器中给容器附初值的方法vector&lt;int&gt; a1(a,a+5);//或将已知初始化的 Array 帮助vector 初始化 6 关于文件的读写，在已经整理的视频笔记中记录的很详细了，不再重复，忘记及时翻看。","link":"/2020/01/16/essential-c-%E5%AD%A6%E4%B9%A0-%E4%B9%8Bc-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"title":"essential c++ 学习--之面向过程编程","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找。由于已经总结了一些视频中的内容，所以只做补充，把不熟悉的内容加进来。 面向过程的编程1 在函数的调用中，有两种参数传递的方式，一种是值传递的方式，一种是地址传递的方式。在之前的视频教程中已经学习过两种方式的区别。已知值传递函数体内部值发生变化，但是主函数并不会发生变化。地址传递函数体内部和主函数都会发生变化。这样就会导致值传递并不能解决课本中的排序问题，需要采用传引用的方式。关注引用，之前有记录它的作用为：给变量起别名，做函数的参数，做函数的返回值。引用的本质是一个指针常量（指针的指向不可以修改，指针指向的值可以修改），引用初始化，不可以发生改变。 当以引用的方式传入主函数时，对象本身并不会复制，对象的地址会进行复制，导致传入的对象进行了间接的操作。 2 关于动态的内存管理，当一些对象的在程序运行完以后，并不想让它消失，需要 int *a=new int(10); 在堆区创建新的内存空间，创建出的对象需要我们手动释放delete a;。可以使我们更好的管理程序。 3 关于局部静态变量，它与全局变量一样存储于全局区。该区域的数据当程序运行完以后由操作系统释放，static int a=10;可以完美解决在主函数中重复调用局部函数变量的问题。 4 关于内敛函数，当程序内容比较大，我们想把每个不同的函数分开，并且有子函数相互调用的情况，在主函数中并不需要把每个子函数都调用，直接调用最外层的函数，inline 会直接调用到最底层的函数。 1234567891011121314151617181920212223#include \"iostream\"using namespace std;void swap(int &amp;a,int &amp;b){ int temp=a; a=b; b=temp; cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;endl;}inline void plus(int &amp;a,int &amp;b)//已经加了 inline{ swap(a,b); a++; b++;} int main(){ int d=3; int c=6; plus(c,d);//直接写 plus，不用再加 swap 函数 cout&lt;&lt;c&lt;&lt;\" \"&lt;&lt;d&lt;&lt;endl; return 0;} 5 关于函数的重载和函数的模板在视频教程中已经详细记录，不再重复。","link":"/2020/01/20/essential-c-%E5%AD%A6%E4%B9%A0-%E4%B9%8B%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B/"},{"title":"关于python的一些学习","text":"注：首先声明，在这文章只是平时的学习笔记，用于加深记忆以及以后方便查找的功能。 1.一些基本的常识python的一些基本语法结构要比c++简单的多，而且写起来很方便，没有像c++那么多的限制，有了一些c++的基础学起来相对容易一些： 关于编译器 ，如果不进行大型的项目，直接创建一个py结尾的文件即可编写python代码，如果运行一些比较大的项目，应该需要下载pychram，这个编译器用起来方便一些，应该需要花钱，但是网上也有一些破解版和汉化的软件，很简单就可以查找到； 和以前学的c++的差别，用了几天感觉差别还是有一些，但是不得不说python是比较方便的软件，而且相比c++代码量比较少，只举一个例子，比如说创建一个函数： 用python 12345678910def func(n): if n==1: return 1 elif n==2: return 1 else: return func(n-1)+func(n-2)n=int(input('请输入一个数; '))result=func(n)print('%d 的斐波那契函数为 %d' %(n,result)) 用c++ 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int func(int i){ if(i==1||i==2) { return 1; } else { return func(i-1)+func(i-2); }};int main(){ int i,result; cout&lt;&lt;\"请输入一个数: \"; cin&gt;&gt;i; result=func(i); cout&lt;&lt; i &lt;&lt;\"的斐波那契函数为：\"&lt;&lt;result&lt;&lt;endl; return 0;} 结果很显然，同样是用递归实现一个斐波那契函数，代码量还是差很多的，关于函数和类的封装继承和多态区别还是有的，但是不大，接下来介绍一个python非常适用的领域爬虫。 2.模拟有道词典实现单词的翻译（爬虫）12345678910111213141516171819202122232425import urllib.requestimport urllib.parseimport json #轻量级的数据交换模式num=input('请输入要翻译的内容：')url='http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule'data={}data['i']= numdata['from']= 'AUTO'data['to']='AUTO'data['smartresult']= 'dict'data['client']= 'fanyideskweb'data['salt']= '15727641027462'data['sign']= '13305999ab8cf444f7ddbc11b62baffd'data['ts']= '1572764102746'data['bv']= '7d4ac98e0e04505e57a74dd5992cc541'data['doctype']= 'json'data['version']= '2.1'data['keyfrom']= 'fanyi.web'data['action']= 'FY_BY_CLICKBUTTION'data=urllib.parse.urlencode(data).encode('utf-8')response=urllib.request.urlopen(url,data)html=response.read().decode('utf-8')a=json.loads(html)b=a['translateResult'][0][0]['tgt']print('翻译结果为: %s' %b) 其中 url='http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule'表示所爬取的链接地址，data 代表了一个字典，存放了各种数据。这些都是从有道的网页后台所爬取的。最后根据你输入的内容即可翻译出相应的结果。 连载中，还在学习中。。。","link":"/2019/11/09/%E5%85%B3%E4%BA%8Epython%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/"},{"title":"关于 x 绝对值的光滑函数","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找。 关于 $|x|$ 的第一个光滑逼近函数定义一个函数 $\\phi: R^2 \\rightarrow R$ 满足$$\\phi(\\mu,x)=\\sqrt{\\mu^{2}+x^{2}}$$ 由于 $|x|$ 本身是不光滑的，但是对于 $\\phi(\\mu,x)$ 来说，该函数在 $(\\mu, x) \\in {R_{++}\\times R}$ 是连续可微的，并且满足对于任给的 $x \\in R$ 有 $\\lim \\limits _{\\mu \\rightarrow 0} \\phi(\\mu, x)=|x|$ 成立，从而我们可以利用 $\\phi(\\mu,x)$ 来把 $|x|$ 光滑化，那么原来的 $|x|$ 是不可求导的变成了可求导 $\\phi(\\mu,x)$，就会有很多良好的性质。 关于 $|x|$ 的第二个光滑逼近函数这种处理办法比较巧妙，我们知道$$\\max{x,0}=\\frac{|x|+x}{2}$$通过解这个方程我们可以得到$$|x|=2\\max{x,0}-x$$对于 $\\max{x,0}$ 我们可以选取它的光滑逼近函数$\\psi(\\mu,x) : R^2 \\rightarrow R$ $$\\psi(\\mu, x)=\\mu\\ln(1+e^{\\frac{x}{\\mu}})$$对于这个函数的构造很好理解，只要 $\\mu$ 足够小以至于 $1+e^{\\frac{x}{\\mu}}$ 可以近似的等于 $e^{\\frac{x}{\\mu}}$ 那么 $$\\psi(\\mu, x)=|x|$$可以利用以下的 matlab 代码去实现该函数 $\\psi(\\mu,x)$ 1234x=input('请输入 x=');a=0.01; %不能取太小, 否则exp(1/a)会很大，导致MATLAB无法显示f=a*log(1+exp(x/a));fprintf('0 与 %6.4d 的最大者为:%6.4d\\n',x,f); 做好的最大值的光滑逼近，那么$$|x|=2\\max{x,0}-x=2\\psi(\\mu,x)-x=2\\mu\\ln(1+e^{\\frac{x}{\\mu}})-x$$其中 $\\mu$ 为一个任意小的正实数。 总结通过以上的两种方式可以对 $|x|$ 进行光滑化，常用的是第一个，它是 NCP-方程的特殊形式，对于一些方程的求解是很有帮助的。","link":"/2019/10/29/%E5%85%B3%E4%BA%8Ex%E7%BB%9D%E5%AF%B9%E5%80%BC%E7%9A%84%E5%85%89%E6%BB%91%E5%87%BD%E6%95%B0/"},{"title":"关于张量互补问题的光滑牛顿法","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找。 关于张量互补问题的一个算法优化前些日子在看一个非光滑牛顿算法解决张量互补问题的论文时，有一点想法并跟导师说了一下，老师说思路可行，但是问题比较小不能表好的论文，但是还是总结到这里吧，万一毕业论文用到呢。 以下是我的思路（注：在上一篇文章会一直更新关于张量互补问题的基本内容，所以关于张量互补问题在这篇文章就不介绍了）： 那篇论文提出的是张量互补问题与一个张量方程组是等价的，也就是下边的内容：A vector $|x|+x \\in R^n$ is a solution of the TCP$(\\mathscr{A},q)$ if and only if the vector $x \\in R^n$ is a solution of the following system of equations:$$|x|-x=\\mathscr{A}(|x|+x)^{m-1}+q$$where $|x|=(|x_1|,|x_2|,\\cdots,|x_n|)^{\\top} \\in R^n$.也就是说$$|x|+x \\geq 0,\\mathscr{A} (|x|+x)^{m-1}+q \\geq 0,\\text { and } (|x|+x)^{\\top}( \\mathscr{A}(|x|+x)^{m-1}+q)= 0$$等价于$$|x|-x=\\mathscr{A}(|x|+x)^{m-1}+q.$$ 关于我的优化思路该论文中所提到的是非光滑牛顿算法，原因很简单有 $|x|$ 的存在，算法不可能是光滑的，但是如果我用光滑逼近函数去逼近 $|x|$，那么可以得到光滑牛顿算法同样可以解决这个问题，关于光滑牛顿法要比非光滑牛顿法好太多，有了思路我也尝试着用 MATLAB 对这个算法进行了编写。 程序的设计1.要解决的问题刚才所提到的方程，光滑以后为$$f(\\mu, x):=2x-2\\Psi(\\mu, x)+\\mathscr{A}(2\\Psi(\\mu, x))^{m-1}+q=0.$$其中$$|x|=2\\Psi(\\mu, x)-x:=2\\left(\\begin{array}{c}{\\psi\\left(\\mu, x_{1}\\right)} \\ {\\vdots} \\ {\\psi\\left(\\mu, x_{n}\\right)}\\end{array}\\right)-x,$$$$ \\psi(\\mu, x)=\\mu\\ln(1+e^{\\frac{x}{\\mu}}).$$ 2.算法的流程A Modulus-Based Smoothing Newton Algorithm Step $\\textbf{0}$ Choose $\\sigma \\in(0,1)$, $\\mu &gt;0$ is a sufficient small positive number, $x^{0} \\in R^{n}$. Set $k:=0$.Step $\\textbf{1}$ If $H\\left(x^{k}\\right)=0$, stop. Otherwise, go to Step 2.Step $\\textbf{2}$ Compute $\\Delta x^{k} \\in R^{n}$ by$$f\\left(\\mu,x^{k}\\right)+ f’_x\\left(\\mu,x^{k}\\right) \\Delta x^{k}=0.$$Step $\\textbf{3}$ Let $i_k$ be the minimum of the values $0, 1, 2, \\cdots$ such that$$H\\left(x^{k}+2^{-i_k} \\Delta x^{k}\\right) \\leq H(x^k)+ \\sigma2^{-i_k}\\bigtriangledown H(x^k)^{\\top}\\Delta x^{k}.$$Step $\\textbf{4}$ Set $x^{k+1}:=x^{k}+2^{-i_k} \\Delta x^{k}$ and $k:=k+1.$ Go to Step 1. 3.程序设计以下是我用 MATLAB 做的数值实验的代码：Initialization.m 1234567891011121314151617181920rand('state',0); %&lt;-- Setup for the scriptsubs = [1,1,1,1;2,2,2,2;1,2,2,2;1,1,2,2;2,1,1,1;2,2,1,1]; %&lt;-- Subscripts of the nonzeros.vals = [1;1;-1;1;-1;1];A= sptensor(subs,vals);%离散张量的初始化m=3;n=size(A,1); %A的第一阶的维数%q=randn([n,1]);q=[1;2];Miu_0=0.01; %Choose Miubara &gt;0Delta=0.4; %Choose Delta between (0,1)Sigma=0.3; %Choose Sigma between (0,1/2)x_0=randn([n,1]);z_0=[Miu_0;x_0];HH=H(z_0,A,q,n);norm_0=0.5*norm(HH)^2;k=0;z_k=z_0;Miu_k=Miu_0;x_k=x_0;norm_k=norm_0; smoothing.m 1234567891011121314151617181920212223fprintf('当张量为4阶2维时：\\n');fprintf('当初始向量x_0=(%6.4f , %6.4f),迭代过程为：\\n',x_0); %example 1fprintf('当方程中初始的 q=(%6.4f , %6.4f),迭代过程为：\\n',q);fprintf(' k norm(H(z_k)) Miu_k x_k\\n');tstart = tic; % 计时器，表示计时开始while (norm_k &gt; 1.0e-9) % 终止条件的验证 if rcond(dH(z_k,A,m,n))&gt;1.0e-10; % 确认雅克比矩阵的可逆性 dx_k=(dH(z_k,A,m,n))\\(-HH); %HH 为H dz_k=[0;dx_k]; alpha_k=Alpha(z_k,dz_k,dx_k,Sigma,A,q,m,n); %运行Alpha文件中的函数 x_k = x_k + alpha_k.* dx_k; Miu_k=Miu_0; z_k=[Miu_0;x_k]; k=k+1; HH=H(z_k,A,q,n); norm_k=0.5*norm(HH)^2; fprintf('%4d %10.2d %6.4f (%6.4f , %6.4f)\\n',k, norm_k,Miu_k, x_k);% %10.2d 数的宽度为10，小数点后2位 end;endtelapsed = toc(tstart); %表示终止计时器fprintf('经过 %d 次迭代满足条件,最后各项输出结果为：\\n',k);fprintf(' k x_0 x_k s_k Times norm(H(z_k)) q \\n');fprintf('%4d (%6.4f , %6.4f) (%6.4f , %6.4f) (%6.4f , %6.4f) %6.4f %6.2d (%6.4f , %6.4f)\\n',k,x_0,x_k,s_k,telapsed,norm_k,q); Alpha.m 1234567891011121314function val = Alpha(z_k,dz_k,dx_k,Sigma,A,q,m,n)FLAG = 1;check = 1;while (FLAG) con1=norm(H(z_k+(2^(-check)).*dz_k,A,q,n))^2; %不等式的左边 con2=norm(H(z_k,A,q,n))^2+Sigma*2^(-check)* ((dH(z_k,A,m,n))'*H(z_k,A,q,n))'*dx_k; %不等式的右边 if (con1 &lt;= con2) val = 2^(-check); return; else check = check+1; endendend H.m 12345678910function val =H(z_k,A,q,n)Miu_k=z_k(1);%μ_k 为 z_k 的第一行x_k=z_k(2:n+1); %x_k 为 z_k 的第2行到第n+1行e_k=2*x_k-2*Miu_k*log(1+exp(x_k./Miu_k));c_k=2*Miu_k*log(1+exp(x_k./Miu_k));dd=ttv(A,{c_k,c_k,c_k},[2 3 4]); yk1=double(dd); %转化为小数格式H=e_k+yk1+q;val=H;end dH.m 12345678910111213function val = dH(z_k,A,m,n)Miu_k=z_k(1); %μ_k 为 z_k 的第一行x_k=z_k(2:n+1); %x_k 为 z_k的第二到第n+1行I=eye(n);c_k=2*Miu_k*log(1+exp(x_k/Miu_k));d_k=exp(x_k./Miu_k);e_k=(1+exp(x_k./Miu_k));df3=diag(d_k./e_k);df1=(m-1)*ttv(A,{c_k,c_k}, [3 4] );df11=double(df1);dH=2*I-2*(df3)+df11*2*((df3));val=dH;end 以上就是所有内容，最后得到的结果和论文中的算法一致，所以我的思路应该是正确的。","link":"/2019/10/28/%E5%85%B3%E4%BA%8E%E5%BC%A0%E9%87%8F%E4%BA%92%E8%A1%A5%E9%97%AE%E9%A2%98%E7%9A%84%E5%85%89%E6%BB%91%E7%89%9B%E9%A1%BF%E6%B3%95/"},{"title":"大话数据结构-之串与KMP算法","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找。由于大话数据结构全部为 c 实现的，我准备把代码用 c++ 实现，并把一些重要的笔记记录下来 串与KMP算法 朴素模式匹配算法 1234567891011121314151617181920212223242526272829303132333435int Index(string S,string T,int pos)//表示子串T在pos位置之后第一次与主串S重合，并返回那个位置{ int i=pos-1;//从s[0]开始，所以减一 int j=0; while(i&lt;S.size()&amp;&amp;j&lt;T.size()) { if(S[i]==T[j])//如果匹配，则进行下一个位置的配对 { ++i; ++j; } else { i=i-j+2;//回溯到上一个匹配的首位 j=1; } } if(j&gt;=T.size()) { return i-T.size()+1; } else { return 0; }}int main(){ string S=\"abcdefgabcde\"; string T=\"gabc\"; int a=Index(S,T,3); cout&lt;&lt;a&lt;&lt;endl; return 0;} 这个算法虽然能够计算出子串在主串的位置，但是效率低下，KMP算法主要解决回溯问题。 KMP算法 这个算法主要引进了next数组，针对在失配的时候的回溯问题。而且可以发现回溯问题与主串其实无关，主要看子串中重复的字符。比如T=”aabaac”；它的next 为 012123.在哪个位置失配直接回溯到next位置，防止没有必要的回溯出现。next很好求，只要看他前面位置的前缀与后缀重复的字符数然后加1，即为next数组的个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void get_Index(string T,int *next){ int i=1; int j=0; next[0]=0; while(i&lt;T.size()) { if(j==0||T[i-1]==T[j-1]) { ++i; ++j; next[i-1]=j; } else { j=next[j-1]; } }}int Index_KMP(string S,string T,int pos){ int i=pos; int j=1; int next[50]; get_Index(T,next); while(i&lt;=S.size()&amp;&amp;j&lt;=T.size()) { if(j==0||S[i-1]==T[j-1]) { ++i; ++j; } else { j=next[j-1]; } } if(j&gt;T.size()) { return i-T.size(); } else { return 0; }}int main(){ string S=\"abcdeaafgabcgade\"; string T=\"gabcgad\"; int a=Index_KMP(S,T,2); cout&lt;&lt;a&lt;&lt;endl; return 0;} 除此之外还有一个问题，当子串相邻位置是相等的时候，还会产生回溯的情况，那么我们让上一个相等的next数组来延续这个位置的next数组，就可以避免此事的发生。 1234567891011121314151617181920212223242526void get_Index(string T,int *next){ int i=1; int j=0; next[0]=0; while(i&lt;T.size()) { if(j==0||T[i-1]==T[j-1]) { ++i; ++j; if(T[i-1]!=T[j-1])//加一个判断是否相等的式子即可 { next[i-1]=j; } else { next[i-1]=next[j-1]; } } else { j=next[j-1]; } }}","link":"/2020/02/04/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B9%8B%E4%B8%B2%E4%B8%8EKMP%E7%AE%97%E6%B3%95/"},{"title":"常见排序算法总结","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找。 今天主要整理了几种排序算法，参考书籍为《大话数据结构》，用 c++ 实现的。首先看这几种排序算法的关系 冒泡排序最初的冒泡排序算法，本文章的所有进行排序的数据用 vector 容器存放，后边不再重复。 12345678910111213141516171819202122232425262728293031323334353637383940#include \"iostream\"#include&lt;vector&gt;using namespace std;void BubbleSort1(vector&lt;int&gt; &amp;v) //第一种冒泡排序{ int i,j; for(i=0;i&lt;v.size();i++) { for(j=i+1;j&lt;v.size();j++) { if(v[i]&gt;v[j]) { int temp=v[i]; v[i]=v[j]; v[j]=temp; } } }}void print(vector&lt;int&gt;v) //用于打印排序后的数据{ for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; } cout&lt;&lt;endl;}int main(){ vector&lt;int&gt; v; v.push_back(2); v.push_back(4); v.push_back(1); v.push_back(5); v.push_back(3); v.push_back(6); BubbleSort1(v); print(v); return 0;} 第二种冒泡排序算法，也是最正宗的排序算法 12345678910111213141516171819202122232425262728293031323334353637383940#include \"iostream\"#include&lt;vector&gt;using namespace std;void BubbleSort1(vector&lt;int&gt; &amp;v) //第二种冒泡排序{ int i,j; for(i=0;i&lt;v.size();i++) { for(j=v.size()-1;j&gt;=i;j--) { if(v[j-1]&gt;v[j]) { int temp=v[j-1]; v[j-1]=v[j]; v[j]=temp; } } }}void print(vector&lt;int&gt;v) //用于打印排序后的数据{ for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; } cout&lt;&lt;endl;}int main(){ vector&lt;int&gt; v; v.push_back(2); v.push_back(4); v.push_back(1); v.push_back(5); v.push_back(3); v.push_back(6); BubbleSort1(v); print(v); return 0;} 排序算法的优化，在排序的过程中有一些数据不需要交换，把这些用标记变量记下来，只交换另外一些数据 12345678910111213141516171819202122232425262728293031323334353637383940414243#include \"iostream\"#include&lt;vector&gt;using namespace std;void BubbleSort1(vector&lt;int&gt; &amp;v) //第二种冒泡排序{ bool flag=true; //加入了标记变量，确定一些不用交换的数据 int i,j; for(i=0;i&lt;v.size()&amp;&amp;flag;i++) { flag=false; for(j=v.size()-1;j&gt;=i;j--) { if(v[j-1]&gt;v[j]) { int temp=v[j-1]; v[j-1]=v[j]; v[j]=temp; flag=true; } } }}void print(vector&lt;int&gt;v) //用于打印排序后的数据{ for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; } cout&lt;&lt;endl;}int main(){ vector&lt;int&gt; v; v.push_back(2); v.push_back(4); v.push_back(1); v.push_back(5); v.push_back(3); v.push_back(6); BubbleSort1(v); print(v); return 0;} 选择排序算法基本思想就是先选定一个最小值，用其他的值与其比较，进行交换顺序，从而保证排序是从小到大排列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include \"iostream\"#include&lt;vector&gt;using namespace std;void SelectSort(vector&lt;int&gt; &amp;v) //选择排序算法{ int i,j,min; for(i=0;i&lt;v.size();i++) { min=i; for(j=i+1;j&lt;v.size();j++) { if(v[min]&gt;v[j]) { min=j; } } if(i!=min) { int temp=v[min]; v[min]=v[i]; v[i]=temp; } }}void print(vector&lt;int&gt;v) //用于打印排序后的数据{ for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; } cout&lt;&lt;endl;}int main(){ vector&lt;int&gt; v; v.push_back(2); v.push_back(4); v.push_back(1); v.push_back(5); v.push_back(3); v.push_back(6); SelectSort(v); print(v); return 0;} 直接插入排序算法12345678910111213141516171819202122232425262728293031323334353637383940#include \"iostream\"#include&lt;vector&gt;using namespace std;void InsertSort(vector&lt;int&gt; &amp;v) //直接插入排序算法{ int i,j; for(i=1;i&lt;v.size();i++) { if(v[i]&lt;v[i-1]) { int temp=v[i]; for(j=i-1;v[j]&gt;temp;j--) { v[j+1]=v[j]; } v[j+1]=temp; } }}void print(vector&lt;int&gt;v) //用于打印排序后的数据{ for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; } cout&lt;&lt;endl;}int main(){ vector&lt;int&gt; v; v.push_back(2); v.push_back(4); v.push_back(1); v.push_back(5); v.push_back(3); v.push_back(6); InsertSort(v); print(v); return 0;} 希尔排序算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include \"iostream\"#include&lt;vector&gt;using namespace std;void ShellSort(vector&lt;int&gt; &amp;v) //希尔排序算法{ int i,j; int inc=v.size(); do { inc=inc/3+1; for(i=inc+1;i&lt;v.size();i++) { if(v[i]&lt;v[i-inc]) { int temp=v[i]; for(j=i-inc;j&gt;=0&amp;&amp;temp&lt;v[j];j-=inc) { v[j+inc]=v[j]; } v[j+inc]=temp; } } } while(inc&gt;1);}void print(vector&lt;int&gt;v) //用于打印排序后的数据{ for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; } cout&lt;&lt;endl;}int main(){ vector&lt;int&gt; v; v.push_back(2); v.push_back(4); v.push_back(1); v.push_back(5); v.push_back(3); v.push_back(6); ShellSort(v); print(v); return 0;} 堆排序算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include \"iostream\"#include&lt;vector&gt;using namespace std;void HeapAdjust(vector&lt;int&gt; &amp;v,int s,int m){ int temp,j; temp=v[s]; for(j=2*s;j&lt;=m;j*=2) { if(j&lt;m&amp;&amp;v[j]&lt;v[j+1]) { j++; } if(temp&gt;v[j]) { break; } v[s]=v[j]; s=j; } v[s]=temp;}void HeapSort(vector&lt;int&gt; &amp;v) //堆排序算法{ int i; for(i=v.size()/2;i&gt;=0;i--) { HeapAdjust(v,i,v.size()-1); } for(i=v.size()-1;i&gt;0;i--) { int temp=v[0]; v[0]=v[i]; v[i]=temp; HeapAdjust(v,0,i-1); }}void print(vector&lt;int&gt;v) //用于打印排序后的数据{ for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; } cout&lt;&lt;endl;}int main(){ vector&lt;int&gt; v; v.push_back(2); v.push_back(4); v.push_back(1); v.push_back(5); v.push_back(3); v.push_back(6); HeapSort(v); print(v); return 0;} 快速排序算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include \"iostream\"#include&lt;vector&gt;using namespace std;int Partition(vector&lt;int&gt; &amp;v,int low,int high){ int pivotkey; pivotkey=v[low]; while(low&lt;high) { while(low&lt;high&amp;&amp;v[high]&gt;pivotkey) { high--; } int temp1=v[low]; v[low]=v[high]; v[high]=temp1; while(low&lt;high&amp;&amp;v[low]&lt;pivotkey) { low++; } int temp2=v[low]; v[low]=v[high]; v[high]=temp2; } return low;}void QSort(vector&lt;int&gt; &amp;v,int low,int high){ int pivot; if(low&lt;high) { pivot=Partition(v,low,high); QSort(v,low,pivot-1); QSort(v,pivot+1,high); }}void QuickSort(vector&lt;int&gt; &amp;v){ QSort(v,0,v.size()-1);}void print(vector&lt;int&gt;v) //用于打印排序后的数据{ for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; } cout&lt;&lt;endl;}int main(){ vector&lt;int&gt; v; v.push_back(2); v.push_back(4); v.push_back(1); v.push_back(5); v.push_back(3); v.push_back(6); QuickSort(v); print(v); return 0;}","link":"/2019/11/24/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"title":"寒假安排","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找。 今年寒假放假比较早，经导师允许10号就回家，打算先歇几天，寒假主要的任务有几本 c++ 的书籍（借了essential c++，大话数据结构，c++ primer），导师发了几个文献，一个论文的计算部分的程序编写，齐次我还打算把一些张量互补问题的内容进行总结，为以后的毕业论文打下基础。下表为今年寒假的主要任务： 日期 任务 1月15日–1月23日 完成老师留下论文的计算编程部分，读文献，把放下的 c++ 拾起来 1月26–2月7日 复习上学期学过的大话数据结构，学习 essential c++ 整理张量互补问题的内容 2月8日–2月16日 复习 Python 把那个打飞机的小游戏做出来，看 c++primer ，读文献 任务还是比较多的，可能会完不成，但是整个寒假没有闲着就可以了。加油！！","link":"/2020/01/10/%E5%AF%92%E5%81%87%E5%AE%89%E6%8E%92/"},{"title":"大话数据结构-之线性表","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找。由于大话数据结构全部为 c 实现的，我准备把代码用 c++ 实现，并把一些重要的笔记记录下来 线性表的顺序存储结构线性表的概念：零个或者多个数据元素的有限序列。记为（$a_1$,…$a_{i-1}$,$a_i$,$a_{i+1}$,….$a_n$），其中 $a_{i-1}$ 为 $a_i$ 的前驱元素， $a_{i+1}$ 为 $a_i$ 的后继元素。 顺序线性表的结构代码： 1234567const int Max=15;class SqList{public: int data[Max];//存储的元素 int length;//当前线性表的长度}; 在做数据的插入与删除之前，应当学习数据的获取 123456789101112bool Getlem(SqList L,int i,int *e){ if(L.length==0||i&lt;1||i&gt;L.length) { return false; } else { *e=L.data[i-1]; return true; }} 顺序表的插入 12345678910111213141516171819202122bool ListInsert(SqList *L,int i,int e){ int k; if(L-&gt;length==Max) { return false; } else if(i&lt;1||i&gt;L-&gt;length+1) { return false; } else if(i&lt;=L-&gt;length) { for(k=L-&gt;length-1;k&gt;=i-1;k--) { L-&gt;data[k+1]=L-&gt;data[k]; } } L-&gt;data[i-1]=e; L-&gt;length++; return true;} 顺序表的删除操作 12345678910111213141516171819202122bool ListDelete(SqList *L,int i,int *e){ int k; if(L-&gt;length==0) { return false; } else if(i&lt;1||i&gt;L-&gt;length) { return false; } *e=L-&gt;data[i-1]; if(i&lt;L-&gt;length) { for(k=i;k&lt;L-&gt;length;k++) { L-&gt;data[k-1]=L-&gt;data[k]; } } L-&gt;length--; return true;} 线性表的链式存储结构由有限个节点组成的链表称为线性表的链式存储结构，每个节点由一个数据域和一个指针域组成。数据域存储数据，指针域存储后一个数据域的指针。单链表的创建 123456class LinkList{public: int data;//数据域 LinkList *next;//下一个数据域的指针} 单链表的读取 1234567891011121314151617bool GetElem(LinkList L,int i,int *e){ int j=1; LinkList p; p=L-&gt;next; while(p&amp;&amp;j&lt;i) { p=p-&gt;next; ++j; } if(!p||j&gt;=i) { return false; } *e=p-&gt;data; return true;} 单链表的插入操作 123456789101112131415161718192021bool ListInsert(LinkList *L,int i,int e){ int j; LinkList p,s; p=*L; j=1; while(p&amp;&amp;j&lt;i) { p=p-&gt;next; ++j; } if(!p||j&gt;=i) { return false; } s=(LinkList)malloc(sizeof(LinkList)); s-&gt;data=e; s-&gt;next=p-&gt;next; p-&gt;next=s; return true;} 单链表的删除操作 12345678910111213141516171819bool ListDelete(LinkList *L,int i,int *e){ int j; LinkList p; p=*L; j=1; while(p-&gt;next&amp;&amp;j&lt;i) { p=p-&gt;next; j++; } if(!(p-&gt;next)||j&gt;=i) { return false; } p-&gt;next=p-&gt;next-&gt;next; *e=p-&gt;next-&gt;data; return true;} 还有静态链表、双向链表和循环链表","link":"/2019/11/05/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"title":"常见的几个c++小程序（职工管理系统）","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找。 职工管理系统的功能简介该程序可以实现增加职工信息（主要有员工、经理、老板三类职工）、显示职工信息、删除职工信息、修改职工信息、查找职工信息、按照员工编号排序、清除职工的所有信息。基本满足了所有的需求。 实现的代码职工管理系统.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;#include \"workmanager.h\"int main(){ WorkerManager wm; int choice=0; while(true) { wm.Show_Menu(); cout&lt;&lt;\"请输入要进行的操作：\"; cin&gt;&gt;choice; switch(choice) { case 0://退出系统 wm.ExitSystem(); break; case 1://添加员工 wm.Add_Emp(); break; case 2://显示员工 wm.Show_Emp(); break; case 3://删除员工 wm.Del_Emp(); break; case 4://修改员工 wm.Chan_Emp(); break; case 5://查找员工 wm.Find_Emp(); break; case 6://排序员工 wm.Sort_Emp(); break; case 7://清空文件 wm.Clean_Emp(); break; default: system(\"cls\"); break; } } system(\"pause\"); return 0;} boss.h 1234567891011#pragma once#include&lt;iostream&gt;#include \"work.h\"using namespace std;class Boss: public Worker{public: Boss(int id,string name,int did);//构造函数 void showInfo();//显示个人信息 string getDeptName();//获取岗位}; workmanager.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482#include \"workmanager.h\"WorkerManager::WorkerManager()//构造函数的空实现{ ifstream ifs; ifs.open(FILENAME,ios::in);//读文件 if(!ifs.is_open())//首先读取文件是否存在 { cout&lt;&lt;\"系统之前没有添加过任何数据，开始添加吧!\"&lt;&lt;endl; this-&gt;m_EmpNum=0;//人数为零 this-&gt;m_EmpArray=NULL;//数组为空 this-&gt;m_FileEmpty=true; ifs.close(); return; } else { char ch; ifs&gt;&gt;ch; if(ifs.eof())//eof为读取文件存在，是否为空的函数 { cout&lt;&lt;\"文件存在，但是是个空文件!\"&lt;&lt;endl; this-&gt;m_EmpNum=0;//人数为零 this-&gt;m_EmpArray=NULL;//数组为空 this-&gt;m_FileEmpty=true; ifs.close(); return; } else { cout&lt;&lt;\"目前系统内所含职工人数为：\"&lt;&lt;this-&gt;get_EmpNum()&lt;&lt;endl; this-&gt;m_EmpNum=this-&gt;get_EmpNum(); this-&gt;m_EmpArray=new Worker*[this-&gt;m_EmpNum];//先开辟新的空间 this-&gt;init_Emp();//相应的数组内填数据 this-&gt;m_FileEmpty=false;//文件中有内容，为false for(int i=0;i &lt; this-&gt;get_EmpNum();i++) { cout&lt;&lt;\"员工ID: \"&lt;&lt;this-&gt;m_EmpArray[i]-&gt;m_Id &lt;&lt;\" 员工姓名: \"&lt;&lt;this-&gt;m_EmpArray[i]-&gt;m_Name &lt;&lt;\" 员工职位: \"&lt;&lt;this-&gt;m_EmpArray[i]-&gt;getDeptName()&lt;&lt;endl; } } }}void WorkerManager::Add_Emp(){ cout&lt;&lt;\"请输入添加职工的数量：\"; int addNum=0; cin&gt;&gt;addNum; if(addNum&gt;0) { //计算添加的空间的大小 int newSize=this-&gt;m_EmpNum+addNum; Worker ** newSpace=new Worker*[newSize];//开辟新空间 if(this-&gt;m_EmpArray!=NULL)//先将原来的数据拷贝过来 { for(int i=0;i&lt;this-&gt;m_EmpNum;i++) { newSpace[i]=this-&gt;m_EmpArray[i]; } } for(int i=0;i&lt;addNum;i++)//添加新数据 { int id; string name; int did; cout&lt;&lt;\"请输入第 \"&lt;&lt;i+1&lt;&lt;\" 个新职工的编号：\"; cin&gt;&gt;id; for(int i=0;i&lt;m_EmpNum;i++) { if(id==this-&gt;m_EmpArray[i]-&gt;m_Id) { cout&lt;&lt;\"抱歉，该ID：\"&lt;&lt;id&lt;&lt;\" 已经有员工使用,请重新输入!\"&lt;&lt;endl; break; } } cout&lt;&lt;\"请输入第 \"&lt;&lt;i+1&lt;&lt;\" 个新职工的姓名：\"; cin&gt;&gt;name; cout&lt;&lt;\"请输入第 \"&lt;&lt;i+1&lt;&lt;\" 个新职工的岗位：\"&lt;&lt;endl; cout&lt;&lt;\"1.普通职工\"&lt;&lt;endl; cout&lt;&lt;\"2.经理\"&lt;&lt;endl; cout&lt;&lt;\"3.老板\"&lt;&lt;endl; cin&gt;&gt;did; Worker *worker=NULL; switch (did) { case 1: worker=new Employee(id,name,1);//构造函数初始化 break; case 2: worker=new Manager(id,name,2); break; case 3: worker=new Boss(id,name,3); break; default: break; } newSpace [this-&gt;m_EmpNum+i]=worker;//新加的数据保存到数组中 } //释放空间 delete[] this-&gt;m_EmpArray; //更改空间指向 this-&gt;m_EmpArray=newSpace; //更新职工人数 this-&gt;m_EmpNum=newSize;//即 原有+新增 this-&gt;m_FileEmpty=false; cout&lt;&lt;\"成功添加了 \"&lt;&lt;addNum&lt;&lt;\" 名职工!\"&lt;&lt;endl; this-&gt;save(); } else if(addNum&lt;=0) { cout&lt;&lt;\"你的添加有误，请输入大于零的整数\"&lt;&lt;endl; } system(\"pause\"); system(\"cls\");}void WorkerManager::save(){ ofstream ofs; ofs.open(FILENAME,ios::out);//以写文件的格式打开 for(int i=0;i&lt;this-&gt;m_EmpNum;i++) { ofs&lt;&lt;\"ID: \"&lt;&lt;this-&gt;m_EmpArray[i]-&gt;m_Id&lt;&lt;\" \" &lt;&lt;\"姓名: \"&lt;&lt;this-&gt;m_EmpArray[i]-&gt;m_Name&lt;&lt;\" \" &lt;&lt;\"职位: \"&lt;&lt;this-&gt;m_EmpArray[i]-&gt;getDeptName()&lt;&lt;endl; } ofs.close();}void WorkerManager::Show_Menu(){ cout&lt;&lt;\"+++++++++++++++++++++++++++++++++++++++++\"&lt;&lt;endl; cout&lt;&lt;\"+++++++= 欢迎使用职工管理系统 =++++++++\"&lt;&lt;endl; cout&lt;&lt;\"++++++++++= 0 退出管理系统 =+++++++++++\"&lt;&lt;endl; cout&lt;&lt;\"++++++++++= 1 增加职工信息 =+++++++++++\"&lt;&lt;endl; cout&lt;&lt;\"++++++++++= 2 显示职工信息 =+++++++++++\"&lt;&lt;endl; cout&lt;&lt;\"++++++++++= 3 删除职工信息 =+++++++++++\"&lt;&lt;endl; cout&lt;&lt;\"++++++++++= 4 修改职工信息 =+++++++++++\"&lt;&lt;endl; cout&lt;&lt;\"++++++++++= 5 查找职工信息 =+++++++++++\"&lt;&lt;endl; cout&lt;&lt;\"++++++++++= 6 按照编号排序 =+++++++++++\"&lt;&lt;endl; cout&lt;&lt;\"++++++++++= 7 清空所有文档 =+++++++++++\"&lt;&lt;endl; cout&lt;&lt;\"+++++++++++++++++++++++++++++++++++++++++\"&lt;&lt;endl; cout&lt;&lt;endl; }void WorkerManager::ExitSystem(){ cout&lt;&lt;\"谢谢您的使用，欢迎下次再使用该系统\"&lt;&lt;endl; system(\"pause\"); exit (0);//退出程序的命令，无论再执行哪个步骤，都会退出}int WorkerManager::get_EmpNum()//统计文件中所含数据的个数{ ifstream ifs; ifs.open(FILENAME,ios::in); int id; string name; string did; string w1; string w2; string w3; int num=0; while( ifs&gt;&gt;w1 &amp;&amp; ifs&gt;&gt;id &amp;&amp; ifs&gt;&gt;w2 &amp;&amp; ifs&gt;&gt;name &amp;&amp; ifs&gt;&gt;w3&amp;&amp; ifs&gt;&gt;did) { num++; } return num;}void WorkerManager::init_Emp(){ ifstream ifs; ifs.open(FILENAME,ios::in); int id; string name; string did; string w1; string w2; string w3; int index=0; while( ifs&gt;&gt;w1 &amp;&amp; ifs&gt;&gt;id &amp;&amp; ifs&gt;&gt;w2 &amp;&amp; ifs&gt;&gt;name &amp;&amp; ifs&gt;&gt;w3&amp;&amp; ifs&gt;&gt;did) { Worker *worker=NULL; if(did==\"普通员工\") { int did1=1; worker=new Employee(id,name,did1); } else if(did==\"公司老板\") { int did3=3; worker=new Boss(id,name,did3); } else if(did==\"公司经理\") { int did2=2; worker=new Manager(id,name,did2); } this-&gt;m_EmpArray[index]=worker; index++; } ifs.close();}void WorkerManager::Show_Emp(){ if(this-&gt;m_FileEmpty) { cout&lt;&lt;\"文件不存在或无员工存入!\"&lt;&lt;endl; } else { for(int i=0;i&lt;m_EmpNum;i++) { this-&gt;m_EmpArray[i]-&gt;showInfo(); } } system(\"pause\"); system(\"cls\");}void WorkerManager::Del_Emp(){ if(this-&gt;m_FileEmpty) { cout&lt;&lt;\"文件内容为空，没有可删除的数据。\"&lt;&lt;endl; system(\"pause\"); system(\"cls\"); } else { cout&lt;&lt;\"请输入你要删除的员工的编号：\"&lt;&lt;endl; int id; cin&gt;&gt;id; int index=0;//测试 for(int i=0;i&lt;this-&gt;m_EmpNum;i++) { if(this-&gt;m_EmpArray[i]-&gt;m_Id!=id) { index=-1; } else { index=1; break; } } if(index==1) { cout&lt;&lt;\"编号为: \"&lt;&lt;id&lt;&lt;\" 的员工已删除\"&lt;&lt;endl; for(int j=i;j&lt;this-&gt;m_EmpNum;j++) { this-&gt;m_EmpArray[j]=this-&gt;m_EmpArray[j+1]; } this-&gt;m_EmpNum=this-&gt;m_EmpNum-1; this-&gt;save();//删除数据后，文件更新 system(\"pause\"); system(\"cls\"); } else if(index==-1) { cout&lt;&lt;\"没有查到ID为：\"&lt;&lt;id&lt;&lt;\" 的员工\"&lt;&lt;endl; system(\"pause\"); system(\"cls\"); } }}void WorkerManager::Chan_Emp(){ if(this-&gt;m_FileEmpty) { cout&lt;&lt;\"文件内容为空，没有可修改的数据。\"&lt;&lt;endl; system(\"pause\"); system(\"cls\"); } else { cout&lt;&lt;\"请输入你要修改的员工的编号：\"&lt;&lt;endl; int id; cin&gt;&gt;id; int index=0;//测试 for(int i=0;i&lt;this-&gt;m_EmpNum;i++) { if(this-&gt;m_EmpArray[i]-&gt;m_Id!=id) { index=-1; } else { index=1; break; } } if(index==1) { string name; int did; cout&lt;&lt;\"请输入该职工的编号：\"; cin&gt;&gt;id; cout&lt;&lt;\"请输入该职工的姓名：\"; cin&gt;&gt;name; cout&lt;&lt;\"请输入该职工的岗位：\"&lt;&lt;endl; cout&lt;&lt;\"1.普通职工\"&lt;&lt;endl; cout&lt;&lt;\"2.经理\"&lt;&lt;endl; cout&lt;&lt;\"3.老板\"&lt;&lt;endl; cin&gt;&gt;did; Worker *worker=NULL; switch (did) { case 1: worker=new Employee(id,name,1);//构造函数初始化 break; case 2: worker=new Manager(id,name,2); break; case 3: worker=new Boss(id,name,3); break; default: break; } this-&gt;m_EmpArray[i]=worker; cout&lt;&lt;\"修改成功\"&lt;&lt;endl; this-&gt;save();//修改数据后，文件更新 system(\"pause\"); system(\"cls\"); } else if(index==-1) { cout&lt;&lt;\"没有查到ID为：\"&lt;&lt;id&lt;&lt;\" 的员工\"&lt;&lt;endl; system(\"pause\"); system(\"cls\"); } }}void WorkerManager::Find_Emp()//只能按照ID查找，可改为按照姓名或ID查找{ if(this-&gt;m_FileEmpty) { cout&lt;&lt;\"文件内容为空，没有可查找的数据。\"&lt;&lt;endl; system(\"pause\"); system(\"cls\"); } else { cout&lt;&lt;\"请输入你要查找的员工的编号：\"; int id; cin&gt;&gt;id; int index=0;//测试 for(int i=0;i&lt;this-&gt;m_EmpNum;i++) { if(this-&gt;m_EmpArray[i]-&gt;m_Id!=id) { index=-1; } else { index=1; break; } } if(index==1) { cout&lt;&lt;\"员工ID：\"&lt;&lt;this-&gt;m_EmpArray[i]-&gt;m_Id &lt;&lt;\" 员工姓名：\"&lt;&lt;this-&gt;m_EmpArray[i]-&gt;m_Name &lt;&lt;\" 员工职位：\"&lt;&lt;this-&gt;m_EmpArray[i]-&gt;getDeptName()&lt;&lt;endl; system(\"pause\"); system(\"cls\"); } else if(index==-1) { cout&lt;&lt;\"没有查到ID为：\"&lt;&lt;id&lt;&lt;\" 的员工\"&lt;&lt;endl; system(\"pause\"); system(\"cls\"); } }}void WorkerManager::Sort_Emp()//只能按从小到大，可改为用户自主选择排序方式{ if(this-&gt;m_FileEmpty) { cout&lt;&lt;\"文件内容为空，没有可排序的数据。\"&lt;&lt;endl; system(\"pause\"); system(\"cls\"); } else { for(int i=0;i&lt;this-&gt;m_EmpNum;i++) { for(int j=i+1;j&lt;this-&gt;m_EmpNum;j++) { if(this-&gt;m_EmpArray[i]-&gt;m_Id&gt;this-&gt;m_EmpArray[j]-&gt;m_Id) { Worker *worker=this-&gt;m_EmpArray[i]; this-&gt;m_EmpArray[i]=this-&gt;m_EmpArray[j]; this-&gt;m_EmpArray[j]=worker; } } } cout&lt;&lt;\"排序成功\"&lt;&lt;endl; this-&gt;save();//修改数据后，文件更新 system(\"pause\"); system(\"cls\"); }}void WorkerManager::Clean_Emp(){ cout&lt;&lt;\"你真的确认清空数据吗？\"&lt;&lt;endl; cout&lt;&lt;\"1.确认\"&lt;&lt;endl; cout&lt;&lt;\"2.返回\"&lt;&lt;endl; int select=0; cin&gt;&gt;select; if(select==1) { ofstream ofs(FILENAME,ios::trunc);//如果文件存在删除文件并重新创建 ofs.close(); if(this-&gt;m_EmpArray!=NULL) { //删除对象 for(int i=0;i&lt;this-&gt;m_EmpNum;i++) { delete this-&gt;m_EmpArray[i]; this-&gt;m_EmpArray[i]=NULL; } delete[] this-&gt;m_EmpArray; this-&gt;m_EmpArray=NULL; this-&gt;m_EmpNum=0; this-&gt;m_FileEmpty=true; cout&lt;&lt;\"内容已全部删除!\"&lt;&lt;endl; system(\"pause\"); system(\"cls\"); } } else if(select==2) { system(\"pause\"); system(\"cls\"); }}WorkerManager::~WorkerManager()//析构函数的空实现{ if(this-&gt;m_EmpArray!=NULL) { for(int i=0;i&lt;this-&gt;m_EmpNum;i++) { if(this-&gt;m_EmpArray[i]!=NULL) { delete this-&gt;m_EmpArray[i]; } } delete[] this-&gt;m_EmpArray; this-&gt;m_EmpArray=NULL; }} manager.cpp 1234567891011121314151617181920#include \"manager.h\"Manager::Manager(int id,string name,int did)//构造函数{ this-&gt;m_Id=id; this-&gt;m_Name=name; this-&gt;m_DeptId=did;}void Manager::showInfo()//显示个人信息{ cout&lt;&lt;\"职工编号：\"&lt;&lt;this-&gt;m_Id &lt;&lt;\"\\t职工姓名：\"&lt;&lt;this-&gt;m_Name &lt;&lt;\"\\t职工部门：\"&lt;&lt;this-&gt;getDeptName() &lt;&lt;\"\\t岗位职责：完成老板交给的任务并给员工部署任务\"&lt;&lt;endl;}string Manager::getDeptName()//获取岗位{ return \"公司经理\";} employee.cpp 1234567891011121314151617181920#include \"employee.h\"Employee::Employee(int id,string name,int did)//构造函数{ this-&gt;m_Id=id; this-&gt;m_Name=name; this-&gt;m_DeptId=did;}void Employee::showInfo()//显示个人信息{ cout&lt;&lt;\"职工编号：\"&lt;&lt;this-&gt;m_Id &lt;&lt;\"\\t职工姓名：\"&lt;&lt;this-&gt;m_Name &lt;&lt;\"\\t职工部门：\"&lt;&lt;this-&gt;getDeptName() &lt;&lt;\"\\t岗位职责：完成经理交给的任务\"&lt;&lt;endl;}string Employee::getDeptName()//获取岗位{ return \"普通员工\";} boss.cpp 1234567891011121314151617181920#include \"boss.h\"Boss::Boss(int id,string name,int did)//构造函数{ this-&gt;m_Id=id; this-&gt;m_Name=name; this-&gt;m_DeptId=did;}void Boss::showInfo()//显示个人信息{ cout&lt;&lt;\"职工编号：\"&lt;&lt;this-&gt;m_Id &lt;&lt;\"\\t职工姓名：\"&lt;&lt;this-&gt;m_Name &lt;&lt;\"\\t职工部门：\"&lt;&lt;this-&gt;getDeptName() &lt;&lt;\"\\t岗位职责：给经理部署任务\"&lt;&lt;endl;}string Boss::getDeptName()//获取岗位{ return \"公司老板\";}","link":"/2019/12/12/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E4%B8%AAc-%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%88%E9%80%9A%E8%AE%AF%E5%BD%95%EF%BC%89/"},{"title":"张量互补问题总结","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找。 关于张量互补问题简单介绍张量互补问题所含内容1.张量互补问题的基础知识2.张量互补问题的算法总结3.张量互补问题的应用总结","link":"/2019/10/27/%E5%BC%A0%E9%87%8F%E4%BA%92%E8%A1%A5%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"时间变化凸优化程序","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找。 关于时间变化凸优化前几天有一篇时间变化凸优化的论文，算法部分没有写完，之前没有接触过这类问题，这篇论文的基础知识部分已经写得差不多了，时间变化凸优化第一次是在一个顶级的会议上提出的，它的应用是跟时间有关系，例如机器人过障碍物和边缘碰撞等问题，实质内容就是解决一个含时间变量的函数的最小值的凸优化问题，解决该问题的常见算法有内点法和牛顿法，老师发给我的是牛顿法解决的，想让我把该算法的程序编出来，我准备等论文投出去把问题、算法和程序发出来。 问题是这样的：求一个带不等式和等式约束条件的凸优化问题。我们所采用的算法是牛顿法，具体解决算法在下图：用MATLAB编写的程序是： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647% Import datarand('state',0); %&lt;-- Setup for the script% C_xxx=0.1728;% C_xxt=0.0927;% C_xtt=3.6134;%mu_0=0.001;% w=pi/5;% a=2;% b=1/2;w=0.1;mu=0.1;aerf=4; %变动ybsl=0.00001; %变动t_N=7;x1_0=2;x2_0=0;x3_0=0.5;v_0=0.3;t_0=0;z_0=[x1_0;x2_0;x3_0;v_0];HH=H(z_0,t_0);norm_0=norm(HH);fz2_0=(mu*exp(x1_0+x2_0+x3_0));f_xxx_0=[fz2_0 fz2_0 fz2_0 0 fz2_0 fz2_0 fz2_0 0 fz2_0 fz2_0 fz2_0 0 0 0 0 0;fz2_0 fz2_0 fz2_0 0 fz2_0 fz2_0 fz2_0 0 fz2_0 fz2_0 fz2_0 0 0 0 0 0;fz2_0 fz2_0 fz2_0 0 fz2_0 fz2_0 fz2_0 0 fz2_0 fz2_0 fz2_0 0 0 0 0 0;0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0];%fz1_0=();f_xxt_0=[0 0 0 -w*sin(w*t_0);0 0 0 w*cos(w*t_0);0 0 0 0;-w*sin(w*t_0) w*cos(w*t_0) 0 0];f_xtt_0=[w^2*sin(w*t_0)-v_0*w^2*cos(w*t_0);w^2*cos(w*t_0)-v_0*w^2*sin(w*t_0);0;-w^2*x1_0*cos(w*t_0)-x2_0*w^2*sin(w*t_0)];C_xxx_0=norm(f_xxx_0)+ybsl;C_xxt_0=norm(f_xxt_0)+ybsl;C_xtt_0=norm(f_xtt_0)+ybsl;k=0;x1_k=x1_0;x2_k=x2_0;x3_k=x3_0;v_k=v_0;z_k=z_0;t_k=t_0;f_xxx_k=f_xxx_0;%fz1_k=fz1_0;fz2_k=fz2_0;f_xxt_k=f_xxt_0;f_xtt_k=f_xtt_0;C_xxx_k=C_xxx_0;C_xxt_k=C_xxt_0;C_xtt_k=C_xtt_0;norm_k=norm_0;smoothing % Call file \"inexact_smoothng_SVM\" 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889fprintf('在如下初始条件下,我们得到的结构如下：\\n');fprintf('当初始向量x1_0= %6.4f,x2_0=%6.4f ,x3_0=%6.4f 迭代过程为：\\n',x1_0,x2_0,x3_0); %example 1fprintf(' k norm(H(z_k,t_k)) t_k x1_k x2_k x3_k v_k C_xxx C_xxt C_xtt\\n');tstart = tic; % 计时器，表示计时开始% H 的% fid2=fopen('HH.txt','a'); % fid3=fopen('tk.txt','a'); % count2=fprintf(fid2,' %6.4f ',norm_0);% count3=fprintf(fid3,' %6.4f ',t_0);% fid1=fopen('x1.txt','a'); % fid2=fopen('x2.txt','a'); % fid3=fopen('x3.txt','a'); % fid4=fopen('t.txt','a'); % count1=fprintf(fid1,' %6.4f ',x1_0);% count2=fprintf(fid2,' %6.4f ',x2_0);% count3=fprintf(fid3,' %6.4f ',x3_0);% count4=fprintf(fid4,' %6.4f ',t_0);while (rcond(d_H(z_k,t_k))&gt;1.0e-10) % 验证矩阵的可逆性 fz2_k=(mu*exp(x1_k+x2_k+x3_k)); f_xxx_k=[fz2_k fz2_k fz2_k 0 fz2_k fz2_k fz2_k 0 fz2_k fz2_k fz2_k 0 0 0 0 0;fz2_k fz2_k fz2_k 0 fz2_k fz2_k fz2_k 0 fz2_k fz2_k fz2_k 0 0 0 0 0;fz2_k fz2_k fz2_k 0 fz2_k fz2_k fz2_k 0 fz2_k fz2_k fz2_k 0 0 0 0 0;0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]; %fz1_k=; f_xxt_k=[0 0 0 -w*sin(w*t_k);0 0 0 w*cos(w*t_k);0 0 0 0;-w*sin(w*t_k) w*cos(w*t_k) 0 0]; f_xtt_k=[w^2*sin(w*t_k)-v_k*w^2*cos(w*t_k);w^2*cos(w*t_k)-v_k*w^2*sin(w*t_k);0;-w^2*x1_k*cos(w*t_k)-x2_k*w^2*sin(w*t_k)]; C_xxx_k=norm(f_xxx_k)+ybsl; C_xxt_k=norm(f_xxt_k)+ybsl; C_xtt_k=norm(f_xtt_k)+ybsl; dz_k=(-d_H(z_k,t_k))\\((aerf*H(z_k,t_k)+dt_H(z_k,t_k))); %HH 为H step_k=step(z_k,t_k,norm_k,ybsl,dz_k,C_xxx_k,C_xxt_k,C_xtt_k,aerf); %运行Alpha文件中的函数 %step_k=step(z_k,a,b,mu_0,w,t_k,dz_k,C_xxx,C_xxt,C_xtt,aerf,k,norm_k,ybsl); %运行Alpha文件中的函数 if (t_k+step_k)&lt;t_N; %验证时间 t 在区间内 z_k = z_k + dz_k*step_k; x1_k=z_k(1);%μ_k 为 z_k 的第一行 x2_k=z_k(2); %x_k 为 z_k 的第2行到第n+1行 x3_k=z_k(3); v_k=z_k(4); t_k=t_k+step_k; k=k+1; %HH=(dH(z_k,A,m,n))'*H(z_k,A,q,n); HH=H(z_k,t_k); norm_k=norm(HH); fprintf('%4d %10.2d %6.4f %6.4f %6.4f %6.4f %6.4f %6.4f %6.4f %6.4f \\n',k, norm_k,t_k, x1_k,x2_k,x3_k,v_k,C_xxx_k,C_xxt_k,C_xtt_k);% %10.2d 数的宽度为10，小数点后2 % H 的 %count2=fprintf(fid2,' %6.4f ',norm_k); %count3=fprintf(fid3,' %6.4f ',t_k); % count1=fprintf(fid1,' %6.4f ',x1_k);% count2=fprintf(fid2,' %6.4f ',x2_k);% count3=fprintf(fid3,' %6.4f ',x3_k);% count4=fprintf(fid4,' %6.4f ',t_k); else %考虑最后一个区间当t_k+1&gt;tN时, 把[t_k,tN]作为最后一个区间，求出x_k step_k=t_N-t_k; z_k = z_k + dz_k *step_k; x1_k=z_k(1);%μ_k 为 z_k 的第一行 x2_k=z_k(2); %x_k 为 z_k 的第2行到第n+1行 x3_k=z_k(3); v_k=z_k(4); t_k=t_k+step_k; k=k+1; fprintf('%4d %10.2d %6.6f %6.4f %6.4f %6.4f %6.4f %6.4f %6.4f %6.4f \\n',k, norm_k,t_k, x1_k,x2_k,x3_k,v_k,C_xxx_k,C_xxt_k,C_xtt_k); % H 的 %count2=fprintf(fid2,' %6.4f ',norm_k); %count3=fprintf(fid3,' %6.4f ',t_k); % count1=fprintf(fid1,' %6.4f ',x1_k);% count2=fprintf(fid2,' %6.4f ',x2_k);% count3=fprintf(fid3,' %6.4f ',x3_k);% count4=fprintf(fid4,' %6.4f ',t_k); break; end;endtelapsed = toc(tstart); %表示终止计时器%clo=fclose('all');fprintf('经过 %d 次迭代满足条件,最后各项输出结果为：\\n',k);fprintf(' k x1_k x2_k x3_k Times norm(H(z_k)) \\n');fprintf('%4d %6.4f %6.4f %6.4f %6.4f %6.2d \\n',k,x1_k,x2_k,x3_k,telapsed,norm_k);fprintf('\\n');%point_data %contras 1234567891011121314function val =L(z_k,t_k)%为f(Miu,x_k)函数的构造 okw=0.1;mu=0.1;x1_k=z_k(1);x2_k=z_k(2); x3_k=z_k(3); v_k=z_k(4);e_k=1/2*((x1_k-sin(w*t_k))^2+(x2_k-cos(w*t_k))^2+(x3_k-1)^2)+mu*exp(x1_k+x2_k+x3_k);c_k=(x1_k*cos(w*t_k)+x2_k*sin(w*t_k)+x3_k-1)*v_k;L=e_k+c_k;val=L;end 123456789101112function val =H(z_k,t_k)%为f(Miu,x_k)函数的构造 okw=0.1;%mu=0.1;x1_k=z_k(1);x2_k=z_k(2);x3_k=z_k(3);%v_k=z_k(4);H=[d_L(z_k,t_k);x1_k*cos(w*t_k)+x2_k*sin(w*t_k)+x3_k-1];val=H;end 1234567891011121314function val = d_L(z_k,t_k)w=0.1;mu=0.1;x1_k=z_k(1);x2_k=z_k(2); x3_k=z_k(3);v_k=z_k(4);i1_k=x1_k-sin(w*t_k)+mu*exp(x1_k+x2_k+x3_k)+v_k*cos(w*t_k);i2_k=x2_k-cos(w*t_k)+mu*exp(x1_k+x2_k+x3_k)+v_k*sin(w*t_k);i3_k=x3_k-1+mu*exp(x1_k+x2_k+x3_k)+v_k;d_L=[i1_k;i2_k;i3_k];val=d_L;end 12345678910111213function val = d_H(z_k,t_k)%求f(μ,x)的雅克比矩阵 w=0.1;mu=0.1;x1_k=z_k(1);x2_k=z_k(2);x3_k=z_k(3);%v_k=z_k(4);ddz=(mu*exp(x1_k+x2_k+x3_k));d_H=[1+ddz ddz ddz cos(w*t_k); ddz 1+ddz ddz sin(w*t_k); ddz ddz 1+ddz 1; cos(w*t_k) sin(w*t_k) 1 0];val=d_H;end 123456789101112function val =dt_H(z_k,t_k)%为f(Miu,x_k)函数的构造 okw=0.1;mu=0.1;x1_k=z_k(1); x2_k=z_k(2);%x3_k=z_k(3);v_k=z_k(4);dt_H=[-w*cos(w*t_k)-v_k*w*sin(w*t_k);w*sin(w*t_k)+v_k*w*cos(w*t_k);0;-w*x1_k*sin(w*t_k)+w*x2_k*cos(w*t_k)];val=dt_H;end 1234567891011121314151617181920212223242526272829function val = step(z_k,t_k,norm_k,ybsl,dz_k,C_xxx_k,C_xxt_k,C_xtt_k,aerf)%这个要求的是阿尔法_k ok%dzk是 得他z_k step(z_k,a,b,mu_0,w,t_k,dz_k,C_xxx,C_xxt,C_xtt,aerf,k,norm_k,ybsl)FLAG = 1;while (FLAG) %几个限制条件的表达式% peai_k=1/2*norm(H(z_k,a,b,mu_0,w,t_k))^2;% b_k=(C_xxx*norm(dz_k)+2*C_xxt)*norm(dz_k)+C_xtt;% fai1_k=1/2*b_k*b_k*(t-t_k)^3+3/2*aerf*b^k*sqrt(2*peai_k)*(t-t_k)^2+(b^k*sqrt(2*peai_k)+2*aerf^2*peai_k)*(t-t_k)-2*aerf*peai_k;% %fai11_k=fai1_k;% fai3_k=1/2*b_k*b_k*(c-t_k)^3+3/2*aerf*b^k*sqrt(2*peai_k)*(c-t_k)^2+(b^k*sqrt(2*peai_k)+2*aerf^2*peai_k)*(c-t_k)-2*aerf*peai_k;% %fai31_k=double(fai3_k);% fai2_k=peai_k+int(fai3_k,c,t_k,t); %积分% %fai21_k=fai2_k;% y1=@(t)fai1_k;% y2=@(t)fai2_k; if (norm_k &gt;= (2*ybsl)^(1/2)) val = fai1_k(z_k,t_k,dz_k,C_xxx_k,C_xxt_k,C_xtt_k,aerf)-t_k; %需要添加函数表达式，在t_k附近,函数等于0的值 return; else val=fai2_k(z_k,t_k,dz_k,C_xxx_k,C_xxt_k,C_xtt_k,aerf,ybsl)-t_k;%需要添加函数表达式，反函数的作用 return; endendend 1234567function y=fai1_k(z_k,t_k,dz_k,C_xxx_k,C_xxt_k,C_xtt_k,aerf) peai_k=1/2*norm(H(z_k,t_k))^2; b_k=(C_xxx_k*norm(dz_k,1)+2*C_xxt_k)*norm(dz_k)+C_xtt_k; j=@(t)double(1/2*b_k*b_k*(t-t_k)^3+3/2*aerf*b_k*sqrt(2*peai_k)*(t-t_k)^2+(b_k*sqrt(2*peai_k)+2*aerf^2*peai_k)*(t-t_k)-2*aerf*peai_k); y=fsolve(j,7);end 12345678910function y=fai2_k(z_k,t_k,dz_k,C_xxx_k,C_xxt_k,C_xtt_k,aerf,ybsl) syms c; peai_k=1/2*norm(H(z_k,t_k))^2; b_k=(C_xxx_k*norm(dz_k,1)+2*C_xxt_k)*norm(dz_k)+C_xtt_k; %fai11_k=fai1_k; fai3_k=1/2*b_k*b_k*(c-t_k)^3+3/2*aerf*b_k*sqrt(2*peai_k)*(c-t_k)^2+(b_k*sqrt(2*peai_k)+2*aerf^2*peai_k)*(c-t_k)-2*aerf*peai_k; %fai31_k=double(fai3_k); l=@(t)double(peai_k+int(fai3_k,c,t_k,t)-ybsl); y=fsolve(l,7);end 最后算法的效果图为：","link":"/2019/12/22/%E6%97%B6%E9%97%B4%E5%8F%98%E6%8D%A2%E5%87%B8%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F/"},{"title":"我的第一篇博客","text":"折腾了一天，终于成功了！！！","link":"/2019/10/26/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"},{"title":"梯度下降法解决张量互补问题","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找。 前几天，同学再看一篇梯度下降法求解张量互补问题时，发现结构张量的条件可以降低，他想把这篇文章写出来，在用 Matlab 做算法的程序时遇到了困难，我帮他把程序编完了。该文章的主要思路如下（注：在第一篇文章会一直更新关于张量互补问题的基本内容，所以关于张量互补问题在这篇文章就不介绍了）：那篇论文提出的是张量互补问题与一个张量方程组是等价的，也就是下边的内容： 已知张量互补问题是：$$x \\geq 0,\\mathscr{A} x^{m-1}+q \\geq 0,\\text { and } x^{\\top}( \\mathscr{A}x^{m-1}+q)= 0$$这个式子等价于$$H(x, y)=\\left[\\begin{array}{c}x \\circ y \\y-\\mathscr{A} x^{m-1}-q\\end{array}\\right]=0$$其中 $x\\geq0$, $y\\geq0$.从而转化成求解上面方程组的形式，所选取的张量为强 p 张量，算法流程为：Step 0 令 $s&gt;0$, $\\epsilon&gt;0$ $\\alpha \\in (0,1)$ $\\beta \\in [0,1)$, $\\sigma &gt;0$. 选取 $z^0=(x^0,y^0) \\in R_{++}$, $\\beta_0 \\in [0, \\beta)$ k=0.Step 1 $z=z^k$, 通过求解$$\\left[\\begin{array}{cc}D_{y} &amp; D_{x} \\-(m-1) \\mathcal{A} x^{m-2} &amp; I\\end{array}\\right]\\left[\\begin{array}{l}\\Delta x \\\\Delta y\\end{array}\\right]=\\left[\\begin{array}{c}-D_{x} y+\\beta \\frac{x^{\\top} y}{m} e \\-y+\\mathcal{A} x^{m-1}+q\\end{array}\\right]$$求出方向 $d^k$Step 2 令 $l_k$ 为最小的非负整数，并且通过求解$$\\begin{aligned}z^{k}+\\sigma \\rho^{l} d^{k} &amp; \\in \\Omega_{++} \\\\varphi\\left(z^{k}+\\sigma \\rho^{l} d^{k}\\right)-\\varphi\\left(z^{k}\\right) &amp; \\leq-\\alpha \\sigma \\rho^{l}\\left(1-\\beta_{k}\\right) s\\end{aligned}$$得出步长 $z^{k+1}=z^{k}+\\sigma \\rho^{k^{k}} d^{k}$.Step 3 若 $z^{k+1}$ 满足$f\\left(z^{k+1}\\right)=\\left(x^{k+1}\\right)^{\\top} y^{k+1}+\\left|y^{k+1}-\\mathcal{A}\\left(x^{k+1}\\right)^{m-1}-q\\right|^{2}&lt;\\varepsilon$， 则 $z^{k+1}$ 为张量互补问题的解，如果不满足，那么跳转到 Step 1 ，继续求方向和步长. 算法的程序：Initialization.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152rand('state',0); %&lt;-- Setup for the scriptsubs = [1,1,1,1;1,2,2,2;2,2,2,2]; %&lt;-- Subscripts of the nonzeros.vals = [1;-2;1]; %&lt;-- The values of the nonzeros.% subs = [1,1,1,1;1,2,1,1;2,1,1,1;2,2,1,1;% 1,1,1,2;1,2,1,2;2,1,1,2;2,2,1,2;% 1,1,2,1;1,2,2,1;2,1,2,1;2,2,2,1;% 1,1,2,2;1,2,2,2;2,1,2,2;2,2,2,2;]; %&lt;-- Subscripts of the nonzeros.% vals = [256.0002;0.006;0.006;0.18;0.006;0.18;0.18;5.4;0.006;0.18;0.18;5.4;0.18;5.4;5.4;162]; %vals = [2403;10;10;50;10;50;50;250;10;50;50;250;50;250;250;1250]; A= sptensor(subs,vals); %&lt;----张量初始化 % A(:,:,1,1)=[2403 10;10 50];% A(:,:,1,2)=[10 50;50 250];% A(:,:,2,1)=[10 50;50 250];% A(:,:,2,2)=[50 250;250 1250];% A=tensor(A);% 一些初始元素m=4;n=size(A,1); %A的第一阶的维数%q=randn([n,1]);q=[0; 0];s=1;aref=0.6; %表示 αrou=0.4; %表示 ρSeita=0.8; %表示 σbeta=0.5; %表示 βybsl=1.0e-8; %表示 ε% ************* x_0 与 y_0 的初始化**************% x_0=[0.8147;0.9058];% y_0=[0.1270;0.9137];% x_0=randn([n,1]);% y_0=randn([n,1]);% x_0=[0.9572;0.4854];% y_0=[0.8003;0.1419]; x_0=[95;48]; y_0=[80;14];z_0=[x_0;y_0];HH=f(z_0,A,q,n);norm_0=x_0'*y_0+(norm(HH))^2;k=0;z_k=z_0;y_k=y_0;x_k=x_0;norm_k=norm_0;smoothing %&lt;----接下一个文件 smoothing.m 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950fprintf('当张量为4阶2维时：\\n');fprintf('当初始向量x_0=(%6.4f , %6.4f),迭代过程为：\\n',x_0); %&lt;-----一些初始化的说明fprintf('当方程中初始的 q=(%6.4f , %6.4f),迭代过程为：\\n',q);fprintf(' k norm(H(z_k)) x_k y_k\\n');tstart = tic; % 计时器，表示计时开始% z_k 满足以下条件继续迭代while (norm_k &gt; ybsl ) % 终止条件的验证 if rcond(dH(z_k,A,m,n))&gt;1.0e-10; % 确认雅克比矩阵的可逆性 dz_k=dH(z_k,A,m,n)\\direct_right(z_k,A,n,beta,q); alpha_k=Seita*Alpha(z_k,Seita,dz_k,s,A,q,beta,n,rou,aref,ybsl); %运行Alpha文件中的函数 % if (z_k+alpha_k*dz_k-z_k&lt;ybsl*ones(n+n,1)) % 这个终止条件几乎没用到% for i=1:n% if(log(z_k(i)+alpha_k*dz_k(i))==-log(z_k(n+i)+alpha_k*dz_k(n+i)))% z_k = z_k + alpha_k.* dz_k;% y_k=z_k(n+1:n+n);% x_k=z_k(1:n);% k=k+1;% HH=f(z_k,A,q,n);% norm_k=x_k'*y_k+(norm(HH))^2;% break% end% end% end z_k = z_k + alpha_k.* dz_k; y_k=z_k(n+1:n+n); x_k=z_k(1:n); k=k+1; HH=f(z_k,A,q,n); norm_k=x_k'*y_k+(norm(HH))^2; fprintf('%4d %10.2d (%6.4f , %6.4f) (%6.4f , %6.4f)\\n',k, norm_k,x_k, y_k);% %10.2d 数的宽度为10，小数点后2位 end;endtelapsed = toc(tstart); %表示终止计时器% ************一些最后输出的量************************fprintf('经过 %d 次迭代满足条件,最后各项输出结果为：\\n',k); fprintf(' k x_0 z_k Times norm(H(z_k)) \\n');fprintf('%4d (%6.4f , %6.4f) (%6.4f , %6.4f , %6.4f , %6.4f) %6.4f %6.2d \\n',k,x_0,z_k,telapsed,norm_k);fprintf('\\n');% elseif (z_k+Seita*(rou^check)*dz_k-z_k&lt;ybsl*ones(n+n,1))% for i=1:n% if(log(z_k(i)+Seita*(rou^check)*dz_k(i))==-log(z_k(n+i)+Seita*(rou^check)*dz_k(n+i)))% val = rou^check;% return; % else% check=check+1;% end% end fai.m 12345678910function val=fai(z_k,A,n,s,q)%fai 此函数为 φx_k=z_k(1:n); %x_k 为 z_k 的前n行y_k=z_k(n+1:n+n); %y_k 为 z_k的第n+1到第n+n行dd=ttv(A,{x_k,x_k,x_k},[2 3 4]); y1=double(dd); %转化为小数格式fai=(n+s)*log(x_k'*y_k+(norm(y_k-y1-q))^2)-sum(log(x_k))-sum(log(y_k));val=fai;end H.m 1234567891011function val =H(z_k,A,q,n)%为 H 函数的构造 x_k=z_k(1:n);%x_k 为 z_k 的前n行y_k=z_k(n+1:n+n); %y_k 为 z_k 的第n+1行到第2n行x1=diag(x_k)*y_k;dd=ttv(A,{x_k,x_k,x_k},[2 3 4]); y1=double(dd); %转化为小数格式H=[x1;y_k-y1-q];val=H;end direct_right.m 12345678910function val=direct_right(z_k,A,n,beta,q)% step2 中求方向的等式的右边的函数x_k=z_k(1:n); %x_k 为 z_k 的前n行y_k=z_k(n+1:n+n); %y_k 为 z_k的第n+1到第n+n行dd=ttv(A,{x_k,x_k,x_k},[2 3 4]); y1=double(dd); %转化为小数格式direct_right=[-diag(x_k)*y_k+beta*((x_k'*y_k)/n)*ones(n,1);-y_k+y1+q];val=direct_right;end f.m 12345678910function val =f(z_k,A,q,n)%为更好的使用终止条件，而构造的函数x_k=z_k(1:n);%x_k 为 z_k 的前n行y_k=z_k(n+1:n+n); %y_k 为 z_k 的第n+1行到第2n行dd=ttv(A,{x_k,x_k,x_k},[2 3 4]); y1=double(dd); %转化为小数格式f=y_k-y1-q;val=f;end Alpha.m 12345678910111213141516171819function val = Alpha(z_k,Seita,dz_k,s,A,q,beta,n,rou,aref,ybsl)% 求步长 ρ^l 的函数FLAG = 1;check = 0;while (FLAG) con1=fai(z_k+Seita*(rou^check)*dz_k,A,n,s,q)-fai(z_k,A,n,s,q); %求步长的不等式的左边 con2=-aref*Seita*(rou^check)*(1-beta)*s; %求步长的不等式的右边 %if( norm(f(z_k+Seita*(rou^check)*dz_k,A,q,n),inf)&lt;ybsl) %初始条件的 z_0 根本就没满足 if (con1 &lt;= con2 )% (z_k+Seita*(rou^check)*dz_k) &gt; zeros(n+n,1) &amp; norm(f(z_k+Seita*(rou^check)*dz_k,A,q,n),inf)&lt;ybsl val = rou^check; return; else check=check+1; end %endendend dH.m 1234567891011function val = dH(z_k,A,m,n)%此函数求 H(x_k,y_k) 的雅克比矩阵 x_k=z_k(1:n); %x_k 为 z_k 的前n行y_k=z_k(n+1:n+n); %y_k 为 z_k的第n+1到第n+n行I=eye(n);df=-(m-1)*ttv(A,{x_k,x_k},[3 4]);% 一阶导df1=double(df);dH=[diag(y_k) diag(x_k); df1 I];val=dH;end","link":"/2020/01/05/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95%E8%A7%A3%E5%86%B3%E5%BC%A0%E9%87%8F%E4%BA%92%E8%A1%A5%E9%97%AE%E9%A2%98%E7%9A%84%E7%A8%8B%E5%BA%8F/"},{"title":"欧拉法求解时间变换凸优化","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找。 时间变化凸优化继去年年底，我做的那个时间变化凸优化的数值实验之后，老师最近又发了一篇关于欧拉光滑法的论文，我做的内容还是用MATLAB做程序，把数值实验做出来，这次的算法要比上次的简单一些，但是需要做的数据量很大，在论文投出之后我会把算法以及程序发出来，关于具体解决的问题与去年发的一样，只是采取的算法不同，经验证此算法要好一些。 问题是一样的，算法的流程看下图：通过实例，用MATLAB所做的程序为： 12345678910111213141516171819202122232425% Import datarand('state',0); %&lt;-- Setup for the scriptmu_0=0.001;h=0.1; %变动tau=2;t_N=20;% x1_0=-2;% x2_0=0;x1_0=-2;x2_0=0;lamud_0=0.03;t_0=0;z_0=[x1_0;x2_0;lamud_0];HH=H(z_0,mu_0,t_0);norm_0=norm(HH);k=0;x1_k=x1_0;x2_k=x2_0;lamud_k=lamud_0;z_k=z_0;t_k=t_0;norm_k=norm_0;smoothing % Call file \"inexact_smoothng_SVM\" 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253fprintf('在如下初始条件下,我们得到的结构如下：\\n');fprintf('当初始向量x1_0= %6.12f,x2_0=%6.12f ,lamud_0=%6.12f 迭代过程为：\\n',x1_0,x2_0,lamud_0); %example 1fprintf(' k norm(H(z_k,t_k)) t_k x1_k x2_k lamud_k \\n');tstart = tic; % 计时器，表示计时开始% fid1=fopen('x1_k.txt','a');% fid2=fopen('x2_k.txt','a'); fid4=fopen('HH.txt','a'); fid3=fopen('t_k.txt','a'); % fid5=fopen('err.txt','a'); count3=fprintf(fid3,' %6.4f ',t_k);% count1=fprintf(fid1,' %6.4f ',x1_k); % count2=fprintf(fid2,' %6.4f ',x2_k); count4=fprintf(fid4,' %6.22f ',norm_k);while (rcond(d_H(z_k,mu_0,t_k))&gt;1.0e-10) % 验证矩阵的可逆性 if (t_k&lt;t_N) dz_k=(-d_H(z_k,mu_0,t_k))\\(h*dt_H(z_k,mu_0,t_k)); %HH 为H % j=@(x)H(x,0,t_k);% y=fsolve(j,[0;0;0]);% err=norm(y-z_k);% count5=fprintf(fid5,' %6.18f ',err); z_k = z_k + dz_k; t_k=t_k+h; for s=0:tau-1 z_k=z_k-(d_H(z_k,mu_0,t_k))\\(H(z_k,mu_0,t_k)); end x1_k=z_k(1);%μ_k 为 z_k 的第一行 x2_k=z_k(2); %x_k 为 z_k 的第2行到第n+1行 lamud_k=z_k(3); k=k+1; HH=H(z_k,mu_0,t_k); norm_k=norm(HH); fprintf('%4d %10.2d %6.4f %6.4f %6.4f %6.4f \\n',k, norm_k,t_k, x1_k,x2_k,lamud_k);% %10.2d 数的宽度为10，小数点后2% count1=fprintf(fid1,' %6.4f ',x1_k); % count2=fprintf(fid2,' %6.4f ',x2_k); count3=fprintf(fid3,' %6.4f ',t_k); count4=fprintf(fid4,' %6.22f ',norm_k); else break; endendtelapsed = toc(tstart); %表示终止计时器% count1=fprintf(fid1,' %6.4f \\n',h); % count2=fprintf(fid2,' %6.4f \\n',h); count3=fprintf(fid3,' %6.4f \\n',h); count4=fprintf(fid4,' %6.4f \\n',h);clo=fclose('all');fprintf('经过 %d 次迭代满足条件,最后各项输出结果为：\\n',k);fprintf(' k x1_k x2_k Times norm(H(z_k)) \\n');fprintf('%4d %6.4f %6.4f %6.4f %6.2d \\n',k,x1_k,x2_k,telapsed,norm_k);fprintf('\\n'); 123456789101112function val =L(z_k,t_k)%为f(Miu,x_k)函数的构造 okx1_k=z_k(1);x2_k=z_k(2); lamud_k=z_k(3);e_k=1/2*(x1_k+sin(t_k))^2+3/2*(x2_k+cos(t_k))^2;c_k=(x2_k-x1_k-cos(t_k))*lamud_k;L=e_k+c_k;val=L;end 12345678910function val = d_L(z_k,t_k)x1_k=z_k(1);x2_k=z_k(2); lamud_k=z_k(3);i_k=x1_k+sin(t_k)-lamud_k;m_k=3*(x2_k+cos(t_k))+lamud_k;d_L=[i_k;m_k];val=d_L;end 12345678910function val =H(z_k,mu_0,t_k)%为f(Miu,x_k)函数的构造 okx1_k=z_k(1);x2_k=z_k(2);lamud_k=z_k(3);H=[x1_k+sin(t_k)-lamud_k;3*(x2_k+cos(t_k))+lamud_k;lamud_k-(x2_k-x1_k-cos(t_k))-sqrt((lamud_k+x2_k-x1_k-cos(t_k))^2+4*mu_0^2)];val=H;end 1234567891011function val = d_H(z_k,mu_0,t_k)%求f(μ,x)的雅克比矩阵 x1_k=z_k(1);x2_k=z_k(2);lamud_k=z_k(3);ddz=(lamud_k+x2_k-x1_k-cos(t_k))/sqrt((lamud_k+x2_k-x1_k-cos(t_k))^2+4*mu_0^2);d_H=[1 0 -1; 0 3 1; 1+ddz -1-ddz 1-ddz];val=d_H;end 12345678910function val =dt_H(z_k,mu_0,t_k)%为f(Miu,x_k)函数的构造 okx1_k=z_k(1); x2_k=z_k(2);lamud_k=z_k(3);dt_H=[cos(t_k);-3*sin(t_k);-sin(t_k)-(sin(t_k)*(lamud_k+x2_k-x1_k-cos(t_k)))/sqrt((lamud_k+x2_k-x1_k-cos(t_k))^2+4*mu_0^2)];val=dt_H;end","link":"/2020/04/20/%E6%AC%A7%E6%8B%89%E6%B3%95%E6%B1%82%E8%A7%A3%E6%97%B6%E9%97%B4%E5%8F%98%E6%8D%A2%E5%87%B8%E4%BC%98%E5%8C%96/"},{"title":"用python实现的打飞机游戏","text":"首先声明：文章只是平时的学习笔记，用于加深记忆以及以后方便查找的功能。 打飞机小游戏的主要功能这个是改编网上的视频教程，从头到尾打下来的，有一定的更改，也有一定的不足，主要功能如下： 飞机发射子弹打敌机，如果发生碰撞，我方和敌方都会爆炸，我方飞机有三条命 敌机有三种，分为大中小，有不同的血条，会提示玩家敌机的剩余学条数，并且随着分数的增加敌机的数量和运动速度会加快。 在一定时间内会有补寄，分为两种，一种是超级子弹，一种是全屏幕炸弹。 这是一些主要的功能，具体内容可以看代码： main.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554import pygame #游戏包import sysimport traceback #更好的退出import myplaneimport enemyimport bulletimport supplyfrom pygame.locals import*pygame.init() #游戏初始化pygame.mixer.init() #混音器初始化bg_size= width,height=480,650 #屏幕的尺寸screen=pygame.display.set_mode(bg_size)pygame.display.set_caption(\"飞机大战小游戏\") #屏幕标题background=pygame.image.load(\"images/background.png\").convert()#血条颜色BLACK=(0,0,0)GREEN=(0,255,0)RED=(255,0,0)WHITE=(255,255,255)#载入音乐pygame.mixer.music.load(\"sound/game_music.wav\") #游戏声音pygame.mixer.music.set_volume(0.2)bullet_sound=pygame.mixer.Sound(\"sound/bullet.wav\") #子弹声音bullet_sound.set_volume(0.2)bomb_sound=pygame.mixer.Sound(\"sound/use_bomb.wav\") #玩家爆炸bomb_sound.set_volume(0.2)supply_sound=pygame.mixer.Sound(\"sound/button.wav\") #补寄的声音supply_sound.set_volume(0.2)get_bomb_sound=pygame.mixer.Sound(\"sound/get_bomb.wav\") #得到补寄炸弹时声音get_bomb_sound.set_volume(0.2)upgrade_sound=pygame.mixer.Sound(\"sound/get_double_laser.wav\") #得到双倍子弹的声音upgrade_sound.set_volume(0.2)upgrade_sound=pygame.mixer.Sound(\"sound/get_double_laser.wav\")#飞机得到子弹 升级的声音upgrade_sound.set_volume(0.2)enemy3_fly_sound=pygame.mixer.Sound(\"sound/enemy2_out.wav\")#飞机出现enemy3_fly_sound.set_volume(0.2)enemy1_down_sound=pygame.mixer.Sound(\"sound/enemy1_down.wav\")#一号飞机别打enemy1_down_sound.set_volume(0.1)enemy2_down_sound=pygame.mixer.Sound(\"sound/enemy2_down.wav\") #二号飞机被打enemy2_down_sound.set_volume(0.2)enemy3_down_sound=pygame.mixer.Sound(\"sound/enemy3_down.wav\") #三号飞机被打enemy3_down_sound.set_volume(0.2)me_down_sound=pygame.mixer.Sound(\"sound/use_bomb.wav\") #我的飞机被打me_down_sound.set_volume(0.2)def add_small_enemies(group1,group2,num): for i in range(num): e1=enemy.SmallEnemy(bg_size) group1.add(e1) group2.add(e1)def add_mid_enemies(group1,group2,num): for i in range(num): e2=enemy.MidEnemy(bg_size) group1.add(e2) group2.add(e2)def add_big_enemies(group1,group2,num): for i in range(num): e3=enemy.BigEnemy(bg_size) group1.add(e3) group2.add(e3)def inc_speed(target,inc): for each in target: each.speed+=incdef main(): pygame.mixer.music.play(-1) #生成我方飞机 me=myplane.MyPlane(bg_size) #生成敌方飞机 enemies=pygame.sprite.Group() #生成敌方小型飞机 small_enemies=pygame.sprite.Group() add_small_enemies(small_enemies,enemies,15) #生成敌方中型飞机 mid_enemies=pygame.sprite.Group() add_mid_enemies(mid_enemies,enemies,4) #生成敌方大型飞机 big_enemies=pygame.sprite.Group() add_big_enemies(big_enemies,enemies,2) #生成子弹 bullet1=[] bullet1_index=0 BULLET1_NUM=4 for i in range(BULLET1_NUM): bullet1.append(bullet.Bullet1(me.rect.midtop)) #生成双发子弹 bullet2 = [] bullet2_index = 0 BULLET2_NUM = 12 for i in range(BULLET2_NUM//2): bullet2.append(bullet.Bullet2((me.rect.centerx-33, me.rect.centery))) bullet2.append(bullet.Bullet2((me.rect.centerx+30, me.rect.centery))) clock=pygame.time.Clock() #中单图片索引 e1_destroy_index=0 e2_destroy_index=0 e3_destroy_index=0 me_destroy_index=0 #统计得分 score=0 score_font=pygame.font.Font(\"font/fdbsjw.ttf\",28) #游戏停止 paused=False paused_nor_image=pygame.image.load(\"images/game_pause_nor.png\").convert_alpha() paused_pressed_image=pygame.image.load(\"images/game_pause_pressed.png\").convert_alpha() resume_nor_image=pygame.image.load(\"images/game_resume_nor.png\").convert_alpha() resume_pressed_image=pygame.image.load(\"images/game_resume_pressed.png\").convert_alpha() paused_rect=paused_nor_image.get_rect() paused_rect.left,paused_rect.top=width-paused_rect.width-10,10 paused_image=paused_nor_image #设置难度级别 level=1 #全屏炸弹 bomb_image=pygame.image.load(\"images/bomb.png\").convert_alpha() bomb_rect=bomb_image.get_rect() bomb_font=pygame.font.Font(\"font/fdbsjw.ttf\",28) bomb_num=3 #每30 秒发放补给包 bullet_supply=supply.Bullet_Supply(bg_size) bomb_supply=supply.Bomb_Supply(bg_size) SUPPLY_TIME=USEREVENT pygame.time.set_timer(SUPPLY_TIME,30*1000) #双倍子弹定时器 DOUBLE_BULLET_TIME=USEREVENT+1 #判断是否用该子弹 is_double_bullet=False #解除无敌 INVINCIBLE_TIME=USEREVENT+2 #阻止程序重复打开 recorded=False #检测飞机的生命 life_image=pygame.image.load(\"images/life.png\").convert_alpha() life_rect=life_image.get_rect() life_num=3 #游戏结束页面 gameover_font=pygame.font.Font(\"font/fdbsjw.ttf\",48) again_image=pygame.image.load(\"images/game_loading4.png\").convert_alpha() again_rect=again_image.get_rect() gameover_image=pygame.image.load(\"images/game_over.png\").convert_alpha() gameover_rect=gameover_image.get_rect() #切换飞机图片 switch_image=True #延迟飞机图片切换的速度 delay=100 running=True while running: for event in pygame.event.get(): if event.type==QUIT: pygame.quit() sys.exit() elif event.type==MOUSEBUTTONDOWN: if event.button==1 and paused_rect.collidepoint(event.pos): paused= not paused if paused: pygame.time.set_timer(SUPPLY_TIME,0) pygame.mixer.music.pause() pygame.mixer.pause() else: pygame.time.set_timer(SUPPLY_TIME,30*1000) pygame.mixer.music.unpause() pygame.mixer.unpause() elif event.type==MOUSEMOTION or event.type==MOUSEBUTTONUP: if paused_rect.collidepoint(event.pos): if paused: paused_image=resume_pressed_image else: paused_image=paused_pressed_image else: if paused: paused_image=resume_nor_image else: paused_image=paused_nor_image elif event.type==KEYDOWN: if event.key==K_SPACE: if bomb_num: bomb_num-=1 bomb_sound.play() for each in enemies: if each.rect.bottom&gt;0: each.active=False elif event.type==SUPPLY_TIME: supply_sound.play() #if choice[True , False]: # bomb_supply.reset() #else: bullet_supply.reset() elif event.type==DOUBLE_BULLET_TIME: is_double_bullet=False pygame.time.set_timer(DOUBLE_BULLET_TIME,0) elif event.type==INVINCIBLE_TIME: me.invincible=False pygame.time.set_timer(INVINCIBLE_TIME,0) #根据用户的得分增加难度 if level==1 and score&gt;40: level=2 upgrade_sound.play() #增加三小2大 add_small_enemies(small_enemies,enemies,2) add_mid_enemies(mid_enemies,enemies,1) add_big_enemies(big_enemies,enemies,1) #提升速度 inc_speed(small_enemies,1) elif level==2 and score&gt;80: level=3 upgrade_sound.play() #增加三小2大 add_small_enemies(small_enemies,enemies,3) add_mid_enemies(mid_enemies,enemies,1) add_big_enemies(big_enemies,enemies,1) #提升速度 inc_speed(small_enemies,1) inc_speed(mid_enemies,1) elif level==3 and score&gt;160: level=4 upgrade_sound.play() #增加三小2大 add_small_enemies(small_enemies,enemies,5) add_mid_enemies(mid_enemies,enemies,2) add_big_enemies(big_enemies,enemies,1) #提升速度 inc_speed(small_enemies,1) inc_speed(mid_enemies,1) inc_speed(big_enemies,1) #绘制背景 screen.blit(background,(0,0)) if life_num and not paused: #检测键盘操作 key_pressed=pygame.key.get_pressed() if key_pressed[K_w] or key_pressed[K_UP]: me.moveUp() if key_pressed[K_s] or key_pressed[K_DOWN]: me.moveDown() if key_pressed[K_a] or key_pressed[K_LEFT]: me.moveLeft() if key_pressed[K_d] or key_pressed[K_RIGHT]: me.moveRight() #绘制炸弹并检测是否获取 if bomb_supply.active: bomb_supply.move() screen.blit(bomb_supply.image,bomb_supply.rect) if pygame.sprite.collide_mask(bomb_supply,me): get_bomb_sound.play() if bomb_num&lt;3: bomb_num+=1 bomb_supply.active=False #绘制两倍子弹并检测是否获取 if bullet_supply.active: bullet_supply.move() screen.blit(bullet_supply.image,bullet_supply.rect) if pygame.sprite.collide_mask(bullet_supply,me): upgrade_sound.play() #发射子弹 is_double_bullet=True pygame.time.set_timer(DOUBLE_BULLET_TIME,18*1000) bullet_supply.active=False #发射子弹 if not(delay%10): bullet_sound.play() if is_double_bullet: bullets = bullet2 bullets[bullet2_index].reset((me.rect.centerx-33, me.rect.centery)) bullets[bullet2_index+1].reset((me.rect.centerx+30, me.rect.centery)) bullet2_index = (bullet2_index + 2) % BULLET2_NUM else: bullets=bullet1 bullets[bullet1_index].reset(me.rect.midtop) bullet1_index=(bullet1_index+1)%BULLET1_NUM #检测子弹的击中 for b in bullets: if b.active: b.move() screen.blit(b.image,b.rect) enemy_hit=pygame.sprite.spritecollide(b,enemies,False,pygame.sprite.collide_mask) if enemy_hit: b.active=False for e in enemy_hit: e.hit=True if e in mid_enemies or e in big_enemies: e.energy-=1 if e.energy==0: e.active=False else: e.active=False #绘制敌方大型飞机 for each in big_enemies: if each.active: each.move() if each.hit: screen.blit(each.image_hit,each.rect) each.hit=False else: if switch_image: screen.blit(each.image1,each.rect) else: screen.blit(each.image2,each.rect) #绘制血条 pygame.draw.line(screen,BLACK,(each.rect.left,each.rect.top-5),(each.rect.right,each.rect.top-5),2) #生命小于20，显示红色 energy_remain=each.energy/enemy.BigEnemy.energy if energy_remain&gt;0.2: energy_color=GREEN else: energy_color=RED pygame.draw.line(screen,energy_color,(each.rect.left,each.rect.top-5),(each.rect.left+each.rect.width*energy_remain,each.rect.top-5),2) #飞机出现，播放音效 if each.rect.bottom &gt; -50: enemy3_fly_sound.play() else: #毁灭飞机 if not(delay%3): if e3_destroy_index==0: enemy3_down_sound.play(-1) screen.blit(each.destroy_images[e3_destroy_index],each.rect) e3_destroy_index=(e3_destroy_index+1)%6 if e3_destroy_index==0: enemy3_fly_sound.stop() score+=10 each.reset() each.energy=enemy.BigEnemy.energy #绘制中型飞机 for each in mid_enemies: if each.active: each.move() if each.hit: screen.blit(each.image_hit,each.rect) each.hit=False else: screen.blit(each.image,each.rect) #绘制血条 pygame.draw.line(screen,BLACK,(each.rect.left,each.rect.top-5),(each.rect.right,each.rect.top-5),2) #生命小于20，显示红色 energy_remain=each.energy/enemy.MidEnemy.energy if energy_remain&gt;0.2: energy_color=GREEN else: energy_color=RED pygame.draw.line(screen,energy_color,(each.rect.left,each.rect.top-5),(each.rect.left+each.rect.width*energy_remain,each.rect.top-5),2) else: #毁灭飞机 if not(delay%3): if e2_destroy_index==0: enemy2_down_sound.play() screen.blit(each.destroy_images[e2_destroy_index],each.rect) e2_destroy_index=(e2_destroy_index+1)%4 if e2_destroy_index==0: score+=6 each.reset() each.energy=enemy.MidEnemy.energy #复活后，重新获得血条 #绘制小型飞机 for each in small_enemies: if each.active: each.move() screen.blit(each.image,each.rect) else: #毁灭飞机 if not(delay%3): if e1_destroy_index==0: enemy1_down_sound.play() screen.blit(each.destroy_images[e1_destroy_index],each.rect) e1_destroy_index=(e1_destroy_index+1)%4 if e1_destroy_index==0: score+=1 each.reset() #检测飞机碰撞 enemies_down=pygame.sprite.spritecollide(me,enemies,False,pygame.sprite.collide_mask) if enemies_down and not me.invincible: me.active= False for e in enemies_down: e.active=False #绘制我方飞机 switch_image=not switch_image if me.active: if switch_image: screen.blit(me.image1,me.rect) else: screen.blit(me.image2,me.rect) else: #毁灭飞机 if not(delay%3): if me_destroy_index==0: me_down_sound.play() screen.blit(me.destroy_images[me_destroy_index],me.rect) me_destroy_index=(me_destroy_index+1)%4 if me_destroy_index==0: life_num-=1 me.reset() pygame.time.set_timer(INVINCIBLE_TIME,3*1000) #全屏炸弹显示 bomb_text=bomb_font.render(\"x %d\"%bomb_num,True,WHITE) text_rect=bomb_text.get_rect() screen.blit(bomb_image,(10,height-10-bomb_rect.height)) screen.blit(bomb_text,(20+bomb_rect.width,height-5-text_rect.height)) ##绘制生命余量 if life_num: for i in range(life_num): screen.blit(life_image,(width-10-(i+1)*life_rect.width,height-10-life_rect.height)) #游戏得分 score_text=score_font.render(\"Score：%s\"%str(score),True,WHITE) screen.blit(score_text,(10,5)) #绘制游戏结束 elif life_num==0: #背景音乐停止 pygame.mixer.music.stop() #停止全部音效 pygame.mixer.stop() #停止发放补寄 pygame.time.set_timer(SUPPLY_TIME,0) if not recorded: recorded=True #读取历史最高得分 with open(\"record.txt\",\"r\") as f: record_score=int(f.read()) #分数存档 if score&gt;record_score: with open(\"record.txt\",\"w\") as f: f.write(str(score)) #绘制结束界面 record_score_text = score_font.render(\"Best : %d\" % record_score, True, (255, 255, 255)) screen.blit(record_score_text, (50, 50)) gameover_text1 = gameover_font.render(\"Your Score\", True, (255, 255, 255)) gameover_text1_rect = gameover_text1.get_rect() gameover_text1_rect.left, gameover_text1_rect.top =(width - gameover_text1_rect.width) // 2, height // 3 screen.blit(gameover_text1, gameover_text1_rect) gameover_text2 = gameover_font.render(str(score), True, (255, 255, 255)) gameover_text2_rect = gameover_text2.get_rect() gameover_text2_rect.left, gameover_text2_rect.top = (width - gameover_text2_rect.width) // 2,gameover_text1_rect.bottom + 10 screen.blit(gameover_text2, gameover_text2_rect) again_rect.left, again_rect.top = (width - again_rect.width) // 2,gameover_text2_rect.bottom + 50 screen.blit(again_image, again_rect) gameover_rect.left, gameover_rect.top =(width - again_rect.width) // 2,again_rect.bottom + 10 screen.blit(gameover_image, gameover_rect) # 检测用户的鼠标操作 # 如果用户按下鼠标左键 if pygame.mouse.get_pressed()[0]: # 获取鼠标坐标 pos = pygame.mouse.get_pos() # 如果用户点击“重新开始” if again_rect.left &lt; pos[0] &lt; again_rect.right and again_rect.top &lt; pos[1] &lt; again_rect.bottom: # 调用main函数，重新开始游戏 main() # 如果用户点击“结束游戏” elif gameover_rect.left &lt; pos[0] &lt; gameover_rect.right and gameover_rect.top &lt; pos[1] &lt; gameover_rect.bottom: # 退出游戏 pygame.quit() sys.exit() #显示暂停 screen.blit(paused_image,paused_rect) #切换飞机的图片 if not(delay % 5): switch_image=not switch_image delay-=1 if not delay: delay=100 pygame.display.flip() clock.tick(60) if __name__==\"__main__\": try: main() except SystemExit: pass except: traceback.print_exc() pygame.quit() input() bullet.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344import pygameclass Bullet1(pygame.sprite.Sprite): def __init__(self,position): pygame.sprite.Sprite.__init__(self) self.image=pygame.image.load(\"images/bullet1.png\").convert_alpha() self.rect=self.image.get_rect() self.rect.left,self.rect.top=position self.speed=17 self.active=False self.mask=pygame.mask.from_surface(self.image) def move(self): self.rect.top-=self.speed if self.rect.top&lt;0: self.active=False def reset(self,position): self.rect.left,self.rect.top=position self.active=Trueclass Bullet2(pygame.sprite.Sprite): def __init__(self,position): pygame.sprite.Sprite.__init__(self) self.image=pygame.image.load(\"images/bullet2.png\").convert_alpha() self.rect=self.image.get_rect() self.rect.left,self.rect.top=position self.speed=20 self.active=False self.mask=pygame.mask.from_surface(self.image) def move(self): self.rect.top-=self.speed if self.rect.top&lt;0: self.active=False def reset(self,position): self.rect.left,self.rect.top=position self.active=True enemy.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import pygamefrom random import*class SmallEnemy(pygame.sprite.Sprite): def __init__(self,bg_size): pygame.sprite.Sprite.__init__(self) self.image=pygame.image.load(\"images/enemy1.png\").convert_alpha() self.destroy_images=[] self.destroy_images.extend([pygame.image.load(\"images/enemy1_down1.png\").convert_alpha(),pygame.image.load(\"images/enemy1_down2.png\").convert_alpha(),pygame.image.load(\"images/enemy1_down3.png\").convert_alpha(),pygame.image.load(\"images/enemy1_down4.png\").convert_alpha()]) self.rect=self.image.get_rect() self.width,self.height=bg_size[0],bg_size[1] self.speed=2 #初始速度 self.active=True self.rect.left,self.rect.top=randint(0,self.width-self.rect.width),randint(-5*self.height,0) self.mask=pygame.mask.from_surface(self.image) def move(self): if self.rect.top&lt;self.height: self.rect.top+=self.speed else: self.reset() def reset(self): self.active=True self.rect.left,self.rect.top=randint(0,self.width-self.rect.width),randint(-5*self.height,0) class MidEnemy(pygame.sprite.Sprite): energy=8 def __init__(self,bg_size): pygame.sprite.Sprite.__init__(self) self.image=pygame.image.load(\"images/enemy2.png\").convert_alpha() self.image_hit=pygame.image.load(\"images/enemy2_hit.png\").convert_alpha() self.destroy_images=[] self.destroy_images.extend([pygame.image.load(\"images/enemy2_down1.png\").convert_alpha(),pygame.image.load(\"images/enemy2_down2.png\").convert_alpha(),pygame.image.load(\"images/enemy2_down3.png\").convert_alpha(),pygame.image.load(\"images/enemy2_down4.png\").convert_alpha()]) self.rect=self.image.get_rect() self.width,self.height=bg_size[0],bg_size[1] self.speed=1 self.active=True self.rect.left,self.rect.top=randint(0,self.width-self.rect.width),randint(-10*self.height,-self.height) self.mask=pygame.mask.from_surface(self.image) self.energy=MidEnemy.energy self.hit=False def move(self): if self.rect.top&lt;self.height: self.rect.top+=self.speed else: self.reset() def reset(self): self.active=True self.rect.left,self.rect.top=randint(0,self.width-self.rect.width),randint(-10*self.height,-self.height)class BigEnemy(pygame.sprite.Sprite): energy=20 def __init__(self,bg_size): pygame.sprite.Sprite.__init__(self) self.image1=pygame.image.load(\"images/enemy3_n1.png\").convert_alpha() self.image2=pygame.image.load(\"images/enemy3_n2.png\").convert_alpha() self.image_hit=pygame.image.load(\"images/enemy3_hit.png\").convert_alpha() self.destroy_images=[] self.destroy_images.extend([pygame.image.load(\"images/enemy3_down1.png\").convert_alpha(),pygame.image.load(\"images/enemy3_down2.png\").convert_alpha(),pygame.image.load(\"images/enemy3_down3.png\").convert_alpha(),pygame.image.load(\"images/enemy3_down4.png\").convert_alpha(),pygame.image.load(\"images/enemy3_down5.png\").convert_alpha(),pygame.image.load(\"images/enemy3_down6.png\").convert_alpha()]) self.rect=self.image1.get_rect() self.width,self.height=bg_size[0],bg_size[1] self.speed=1 self.active=True self.rect.left,self.rect.top=randint(0,self.width-self.rect.width),randint(-15*self.height,-5*self.height) self.mask=pygame.mask.from_surface(self.image1) self.energy=BigEnemy.energy self.hit=False def move(self): if self.rect.top&lt;self.height: self.rect.top+=self.speed else: self.reset() def reset(self): self.active=True self.rect.left,self.rect.top=randint(0,self.width-self.rect.width),randint(-15*self.height,-5*self.height) myplane.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import pygameclass MyPlane(pygame.sprite.Sprite): def __init__(self,bg_size): pygame.sprite.Sprite.__init__(self) self.image1=pygame.image.load(\"images/hero1.png\").convert_alpha() self.image2=pygame.image.load(\"images/hero2.png\").convert_alpha() self.destroy_images=[] self.destroy_images.extend([pygame.image.load(\"images/hero_blowup_n1.png\").convert_alpha(),pygame.image.load(\"images/hero_blowup_n2.png\").convert_alpha(),pygame.image.load(\"images/hero_blowup_n3.png\").convert_alpha(),pygame.image.load(\"images/hero_blowup_n4.png\").convert_alpha()]) self.rect=self.image1.get_rect() self.width,self.height=bg_size[0],bg_size[1] self.rect.left,self.rect.top= (self.width-self.rect.width)//2,self.height-self.rect.height-60 self.speed=15 #移动速度 self.active=True self.invincible=False self.mask=pygame.mask.from_surface(self.image1) def moveUp(self): if self.rect.top&gt;0: self.rect.top-=self.speed else: self.rect.top=0 def moveDown(self): if self.rect.bottom&lt;self.height-60: self.rect.top+=self.speed else: self.rect.bottom=self.height-60 def moveLeft(self): if self.rect.left&gt;0: self.rect.left-=self.speed else: self.rect.left=0 def moveRight(self): if self.rect.right&lt;self.width: self.rect.left+=self.speed else: self.rect.right=self.width def reset(self): self.rect.left,self.rect.top= (self.width-self.rect.width)//2,self.height-self.rect.height-60 self.active=True self.invincible=True supply.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445import pygamefrom random import *class Bullet_Supply(pygame.sprite.Sprite): def __init__(self,bg_size): pygame.sprite.Sprite.__init__(self) self.image=pygame.image.load(\"images/ufo1.png\").convert_alpha() self.rect=self.image.get_rect() self.width,self.height=bg_size[0],bg_size[1] self.rect.left,self.rect.bottom=randint(0,self.width-self.rect.width),-100 self.speed=5 self.active=False self.mask=pygame.mask.from_surface(self.image) def move(self): if self.rect.top&lt;self.height: self.rect.top+=self.speed else: self.active=False def reset(self): self.active=True self.rect.left,self.rect.bottom=randint(0,self.width-self.rect.width),-100class Bomb_Supply(pygame.sprite.Sprite): def __init__(self,bg_size): pygame.sprite.Sprite.__init__(self) self.image=pygame.image.load(\"images/ufo2.png\").convert_alpha() self.rect=self.image.get_rect() self.width,self.height=bg_size[0],bg_size[1] self.rect.left,self.rect.bottom=randint(0,self.width-self.rect.width),-100 self.speed=5 self.active=False self.mask=pygame.mask.from_surface(self.image) def move(self): if self.rect.top&lt;self.height: self.rect.top+=self.speed else: self.active=False def reset(self): self.active=True self.rect.left,self.rect.bottom=randint(0,self.width-self.rect.width),-100 有些内容还有待完善，我会定期更新代码。最后放上游戏界面图","link":"/2020/01/19/%E7%94%A8python%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%93%E9%A3%9E%E6%9C%BA%E6%B8%B8%E6%88%8F/"},{"title":"爬取QQ群成员的信息","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找。 因为之前用到了该程序，这是我从网上改编的，通过群来爬取QQ邮箱,感觉非常实用，所以放到这里。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import csvimport timefrom selenium import webdriver# 下拉加载页面def scroll_foot(driver): js=\"var q=document.documentElement.scrollTop=100000\" return driver.execute_script(js)# gid后面写自己要爬取的群号url = \"https://qun.qq.com/member.html#gid=*********\"driver = webdriver.Chrome()driver.get(url)# 要往下滑动的次数，要滑动几次就写几次循环for i in range(6): scroll_foot(driver) time.sleep(1)# 爬出总的扣扣信息elements = driver.find_elements_by_css_selector('tbody.list &gt; tr.mb')with open('2021郑州大学考研总群(*********).txt', 'a+', newline='', encoding='utf-8') as f: writer = csv.writer(f, dialect=\"excel\") writer.writerow(['QQ邮箱']) #writer.writerow(['入群时间'+' ' ,'最后发言'+' ' ,'QQ邮箱'+' ' ,'等级'+' ' ,'昵称']) for element in elements: # print(element.text) name = element.find_element_by_css_selector('td.td-user-nick span').text QQs = element.find_elements_by_css_selector('td') data = {} #data['昵称'] = QQs[2].text data['QQ号'] = QQs[4].text #data['性别'] = QQs[5].text #data['Q龄'] = QQs[6].text #data['入群时间'] = QQs[7].text #data['等级'] = QQs[8].text #data['最后发言'] = QQs[9].text #print(data) if data: # 存入csv中 writer.writerow([data['QQ号']+'@qq.com']) #writer.writerow([data['入群时间']+' ',data['最后发言']+' ',data['QQ号']+'@qq.com',' '+data['等级']+' ',data['昵称']])","link":"/2019/11/19/%E7%88%AC%E5%8F%96QQ%E7%BE%A4%E6%88%90%E5%91%98%E7%9A%84%E4%BF%A1%E6%81%AF/"},{"title":"c++primer的学习笔记7-9","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找，只记录自己不会或者需要补充的内容。 第七章 类 在成员函数中加入int func()const{},变成常量成员函数，并且不能再进行更改。 在类内也有内联函数和函数的重载，与函数的相同，值得注意的是mutable可以把常量成员函数变成可变的成员函数。 在c11中新加了委托构造函数，让其他的构造函数来执行类成员的初始化操作。 静态成员只能由静态成员函数附初值以及调用。并且与其他成员一样都有访问权限。只有静态常量成员可以类内初始化。 首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找，只记录自己不会或者需要补充的内容。 第九章 容器 vector可以在队尾插入或删除元素，deque是双端队列可以在对头或者队尾插入或者删除操作。list是双向链表，可以在任意位置插入或者删除。 使用容器的基本原则：(1)如果没有好的理由最好选用vector.(2)需要随机访问元素的时候用vector或者deque.(3)在对头或者队尾插入或者删除用deque.(4)如果程序既要随机访问元素，又要在中间插入元素，则选用list. 容器的类型成员有：size_type(读取元素)，iterator(检索元素)，const_iterator(写入数据)。 list和array是没有capacity成员函数，list只要加入就会增加内存，array是在创建的时候就已经有固定的内存了,list不支持比较大小的函数。 读入256词，resize后为384.读入512词，resize后为768.读入1000词，resize后为2048.读入1048词，resuze后为2048. 关于string的一些操作，在去年暑假视频已经很全了. 9.11 实例化6种创建和初始化vector对象的方法. 123456vector&lt;int&gt; v1;//初始化为0vector&lt;int&gt; v1(v);//初始化为vvector&lt;int&gt; v1={1,2,3,4};vector&lt;int&gt; v1(v.begin()+1,v.end()-2);vector&lt;int&gt; v1(7);//初始化7个0vector&lt;int&gt; v1(7,3);//初始化7个3 9.13 用list&lt; int &gt; 初始化vector&lt; double &gt; 或者用vector&lt; int &gt;初始化. 1234list&lt;int&gt; l={1,2,3,4,5,6};vector&lt;int&gt; v={1,2,3,4,5};vector&lt;double&gt; v1(l.begin(),l.end());//由于不同类型，不能用拷贝初始化vector&lt;double&gt; v2(v.begin(),v.end());//由于不同类型不能用拷贝初始化","link":"/2020/05/07/c-primer%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07-9/"},{"title":"黑马程序员c++教程（总结暑假的心得）","text":"首先声明：文章只是平时的学习笔记以及一些心得，用于加深记忆以及以后方便查找。 总结：该文章所包含的内容由于之前学过 c 语言的相关内容，所以课程跳过了一些，结构体之前的内容直接跳过了，只做了一个小程序，放在文章的开头，齐次学了 c++ 新加进来的内容，包括：类的封装、继承、多态，类的模板，STL（标准模板库），总体分为以下三个部分，有时间我就会整理进来，做到及时复习，不然会忘得很快。 回顾 c 语言这一部分，由于之前学过 c 语言相关内容，所以只做了一个关于通讯录的例子，但是用 c++ 的标准输入输出流做的，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include&lt;iostream&gt;using namespace std;#include&lt;string&gt;#define MAX 1000//设计联系人的结构体struct Person{ string m_Name; int m_Sex;//想用1代表男 2代表女 int m_Age; string m_Phone; string m_Addr;};//设计通讯录的结构体struct Addressbooks{ //记录通讯录的总体个数和当前已记录的个数 struct Person personArray[MAX]; int m_Size;};// 1 添加人的操作void addPerson(Addressbooks *abs){ if(abs-&gt;m_Size==MAX) { cout&lt;&lt;\"通讯录已满，无法添加！\"&lt;&lt;endl; return; } else { string name; cout&lt;&lt;\"请输入姓名：\"&lt;&lt;endl; cin&gt;&gt;name; abs-&gt;personArray[abs-&gt;m_Size].m_Name=name; int sex=0; cout&lt;&lt;\"请输入性别：\"&lt;&lt;endl; cout&lt;&lt;\"1---男\"&lt;&lt;endl; cout&lt;&lt;\"2---女\"&lt;&lt;endl; while(true) { cin&gt;&gt;sex; if(sex==1||sex==2) { abs-&gt;personArray[abs-&gt;m_Size].m_Sex=sex; break; } cout&lt;&lt;\"你输入错误，请重新输入：\"&lt;&lt;endl; } int age; cout&lt;&lt;\"请输入年龄：\"&lt;&lt;endl; cin&gt;&gt;age; abs-&gt;personArray[abs-&gt;m_Size].m_Age=age; string phone; cout&lt;&lt;\"请输入电话：\"&lt;&lt;endl; cin&gt;&gt;phone; abs-&gt;personArray[abs-&gt;m_Size].m_Phone=phone; string add; cout&lt;&lt;\"请输入住址：\"&lt;&lt;endl; cin&gt;&gt;add; abs-&gt;personArray[abs-&gt;m_Size].m_Addr=add; abs-&gt;m_Size++; cout&lt;&lt;\"你添加成功了！\"&lt;&lt;endl; system(\"pause\");//按任意键继续 system(\"cls\");//清屏的操作 }}// 2 显示联系人void showPerson(Addressbooks *abs){ if(abs-&gt;m_Size==0) { cout&lt;&lt;\"当前的记录为空！\"&lt;&lt;endl; } else { for(int i=0;i&lt;abs-&gt;m_Size;i++) { cout&lt;&lt;\"姓名：\"&lt;&lt;abs-&gt;personArray[i].m_Name&lt;&lt;\"\\t\"; cout&lt;&lt;\"姓别：\"&lt;&lt;(abs-&gt;personArray[i].m_Sex==1 ? \"男\":\"女\")&lt;&lt;\"\\t\"; cout&lt;&lt;\"年龄：\"&lt;&lt;abs-&gt;personArray[i].m_Age&lt;&lt;\"\\t\"; cout&lt;&lt;\"电话：\"&lt;&lt;abs-&gt;personArray[i].m_Phone&lt;&lt;\"\\t\"; cout&lt;&lt;\"住址：\"&lt;&lt;abs-&gt;personArray[i].m_Addr&lt;&lt;endl; } } system(\"pause\"); system(\"cls\");}//删除联系人(其中的查找联系人)int isExist(Addressbooks *abs,string name){ for(int i=0;i&lt;abs-&gt;m_Size;i++) { if(abs-&gt;personArray[i].m_Name==name) { return i; } } return -1;}//删除联系人()void deletePerson(Addressbooks *abs){ cout&lt;&lt;\"请输入你要删除的联系人\"&lt;&lt;endl; string name; cin&gt;&gt;name; int ret=isExist(abs,name); if(ret!=-1) {//查到这个人，让这个人的数据让后面的值覆盖掉 for(int i=ret;i&lt;abs-&gt;m_Size;i++) { abs-&gt;personArray[i]=abs-&gt;personArray[i+1]; } abs-&gt;m_Size--;//前移后所有数据减1 cout&lt;&lt;\"删除成功!\"&lt;&lt;endl; } else cout&lt;&lt;\"没有查到这个人!\"&lt;&lt;endl; system(\"pause\"); system(\"cls\");}//查找联系人void findPerson(Addressbooks *abs){ cout&lt;&lt;\"请输入你要查找的联系人的姓名：\"&lt;&lt;endl; string name; cin&gt;&gt;name; int ret=isExist(abs,name); if(ret!=-1) { cout&lt;&lt;\"找到此人\"&lt;&lt;endl; cout&lt;&lt;\"姓名：\"&lt;&lt;abs-&gt;personArray[ret].m_Name&lt;&lt;\"\\t\"; cout&lt;&lt;\"姓别：\"&lt;&lt;(abs-&gt;personArray[ret].m_Sex==1 ? \"男\":\"女\")&lt;&lt;\"\\t\"; cout&lt;&lt;\"年龄：\"&lt;&lt;abs-&gt;personArray[ret].m_Age&lt;&lt;\"\\t\"; cout&lt;&lt;\"电话：\"&lt;&lt;abs-&gt;personArray[ret].m_Phone&lt;&lt;\"\\t\"; cout&lt;&lt;\"住址：\"&lt;&lt;abs-&gt;personArray[ret].m_Addr&lt;&lt;endl; } else { cout&lt;&lt;\"查无此人!\"&lt;&lt;endl; } system(\"pause\"); system(\"cls\");}//修改联系人void modifyPerson(Addressbooks *abs){ cout&lt;&lt;\"请输入你要修改的联系人\"&lt;&lt;endl; string name; cin&gt;&gt;name; int ret=isExist(abs,name); if(ret!=-1) { string name; cout&lt;&lt;\"请输入姓名：\"&lt;&lt;endl; cin&gt;&gt;name; abs-&gt;personArray[ret].m_Name=name; int sex; cout&lt;&lt;\"请输入性别：\"&lt;&lt;endl; cout&lt;&lt;\"1---男\"&lt;&lt;endl; cout&lt;&lt;\"2---女\"&lt;&lt;endl; while(true)//循环输入，直到输入的内容是正确的 { cin&gt;&gt;sex; if(sex==1||sex==2) { abs-&gt;personArray[ret].m_Sex=sex; break; } else { cout&lt;&lt;\"您输入的有误,请重新输入：\"&lt;&lt;endl; } } int age; cout&lt;&lt;\"请输入年龄：\"&lt;&lt;endl; cin&gt;&gt;age; abs-&gt;personArray[ret].m_Name=age; string phone; cout&lt;&lt;\"请输入联系电话：\"&lt;&lt;endl; cin&gt;&gt;phone; abs-&gt;personArray[ret].m_Phone=phone; cout&lt;&lt;\"请输入家庭住址：\"&lt;&lt;endl; string address; cin&gt;&gt;address; abs-&gt;personArray[ret].m_Addr=address; cout&lt;&lt;\"修改成功！\"&lt;&lt;endl; } else { cout&lt;&lt;\"查无此人\"&lt;&lt;endl; } system(\"pause\"); system(\"cls\");}//清空联系人（使得可传入数据为0）void cleanPerson(Addressbooks *abs){ cout&lt;&lt;\"你确定是否要清空，如果清空请再次输入6\"&lt;&lt;endl; int tem,temp; cin&gt;&gt;tem; cout&lt;&lt;\"请再次确定是否要清空，如果清空请输入6\"&lt;&lt;endl; cin&gt;&gt;temp; if(temp==6) { abs-&gt;m_Size=0; cout&lt;&lt;\"通讯录已经清空\"&lt;&lt;endl; system(\"pause\"); system(\"cls\"); } else { cout&lt;&lt;\"你的数据没有被清空。\"&lt;&lt;endl; system(\"pause\"); }}void show(){ cout&lt;&lt;\"***********************************\"&lt;&lt;endl; cout&lt;&lt;\"********* 1、添加联系人 ***********\"&lt;&lt;endl; cout&lt;&lt;\"********* 2、显示联系人 ***********\"&lt;&lt;endl; cout&lt;&lt;\"********* 3、删除联系人 ***********\"&lt;&lt;endl; cout&lt;&lt;\"********* 4、查找联系人 ***********\"&lt;&lt;endl; cout&lt;&lt;\"********* 5、修改联系人 ***********\"&lt;&lt;endl; cout&lt;&lt;\"********* 6、清空联系人 ***********\"&lt;&lt;endl; cout&lt;&lt;\"********* 0、推出通讯录 ***********\"&lt;&lt;endl; cout&lt;&lt;\"***********************************\"&lt;&lt;endl; cout&lt;&lt;\"* **** * * ****** **** **** *\"&lt;&lt;endl; cout&lt;&lt;\"* * * * * * * * * *\"&lt;&lt;endl; cout&lt;&lt;\"* **** * * * * **** * * *\"&lt;&lt;endl; cout&lt;&lt;\"* * * ** * * * * *\"&lt;&lt;endl; cout&lt;&lt;\"* **** * * * **** * * *\"&lt;&lt;endl; cout&lt;&lt;\"***********************************\"&lt;&lt;endl;}int main(){ Addressbooks abs;//创建结构体变量 abs.m_Size=0; int select =0; while(true) { show(); cin&gt;&gt;select; switch(select) { case 1://添加联系人 addPerson(&amp;abs);//利用地址传递，需要加入一个数进去 break; case 2://显示联系人 showPerson(&amp;abs); break; case 3://删除联系人 deletePerson(&amp;abs); break; case 4://查找联系人 findPerson(&amp;abs); break; case 5://修改联系人 modifyPerson(&amp;abs); break; case 6://清空联系人 cleanPerson(&amp;abs); break; case 0://推出通讯录 cout&lt;&lt;\"欢迎下次使用\"&lt;&lt;endl; system(\"pause\"); return 0; break; default: break; } } system(\"pause\"); return 0;} c++的基础篇内存与引用的基础知识关于内存的分区：代码区、全局区、栈区、堆区。1 代码区：存放 CPU 的机器指令（有共享和只读的性质）2 全局区：全局变量 静态变量 常量区，该区域的数据由操作系统释放全局变量：在函数体外部进行定义静态变量：static int a=10;常量：由字符串常量和 const 修饰的变量，字符串常量是由 “ “ 所引起来的字符串。const修饰的全局变量和局部变量 const int a=10;3 栈区：一般的，局部变量和形参数据都会存放在栈区，不能返回局部变量的地址，变量用一次就会被释放。 4 堆区：由程序员分配释放，在程序结束后由系统回收，在堆区开辟数据（由 new 关键词，开辟到堆区） 12int *p= new int(10) cout&lt;&lt;*p&lt;&lt;endl;//(输出 10 ) 不会像栈区一样，内存不会被释放。 1 new 的基本语法( 在堆区开辟内存 )int *p = new int(10);//new返回的是该数据类型的指针，内存不会被释放，如果想释放用delete。 2 在堆区开辟new的数组 123456int *arr= new int[10];//代表数组一共有10个元素for(int i=0;i&lt;10;i++)//赋值{arr[i]=i+100;}delete[] arr //关于数组的释放 关于引用1 给变量起别名 12int a=10;//引用必须初始化int &amp;b=a;//不可以引用多个（b已经给a引用，不能再给其他引用） 2 引用做函数的参数函数的传递方式：值传递、地址传递、引用传递。 123456789101112131415161718192021// 1 值传递(不改变实参)void swap(int a,int b){ int temp=a; a=b; b=temp;}//在主函数中的a b不会发生改变，但是在这个函数体内部 a,b 会发生改变// 2 地址传递（改变实参的值）void swap2(int *a,int *b)//在main中 swap2(&amp;a,&amp;b);{ int temp=*a; *a=*b; *b=temp;}//会改变实参的值，主函数和该函数的实参都会发生改变// 3 引用传递(改变实参的值)void swap3(int &amp;a,int &amp;b)//在main中swap3(a,b);相当于起别名，所以会改变{ int temp=a; a=b; b=temp;}//也会改变该函数内部实参的值 3 引用做函数的返回值 12345678910111213// 1 不要返回局部变量的引用int &amp;test1()//不能返回引用（a为局部变量）{ int a=10; return a;}//在main函数中，int &amp;ref=test1();(错误的做法)// 2 函数大的调用作为左值int &amp;test2(){ static int a=10; //全局区 return a;}//在main函数中 int &amp;ref=test2();//并且可以作为左值test2()=1000;这里的test2()相当于a,ref相当于a的别名，则ref的值变为了1000 引用的本质引用的本质是一个指针常量（指针的指向不可以修改，指针指向的值可以修改），引用初始化，不可以发生改变 123456789101112void func(int &amp;ref){ ref=100;}int main(){ int a=10; int &amp;ref=a;//自动转换为 int *const ref=&amp;a;指向是不可以更改的 ref=20;//值可以改，指向不可以改 cout&lt;&lt;\"a=\"&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;\"ref=\"&lt;&lt;ref&lt;&lt;endl;} 常用的引用（修饰形参，防止误操作） 123456789101112131415161718192021int main(){ int a=10; int &amp;ref=a;//但是int &amp;ref=10;是错误的 //如果改为 const int &amp;ref=10;//结果正确，等价于const int temp=10;int &amp;ref=temp;}//打印数据的函数void show(int &amp;val){ int val=1000; cout&lt;&lt;\"val=\"&lt;&lt;val&lt;&lt;endl;}int main(){ int a=100; show(a); cout&lt;&lt;\"a=\"&lt;&lt;a&lt;&lt;endl;//a的值已经被修改 //如果不想被修改，则函数的形参前面加一个 const int &amp;val 就可以了} 函数的提高函数的默认值 123456789101112int func(int a,int b,int c){ return a+b+c;}int main(){ cout&lt;&lt;func(1,2,3)&lt;&lt;endl; //如果函数中的形参已经改了几个值，则下面补齐没有的参数即可 //(int a,int b=2,int c=3),下面主函数调用 func(1) //需要注意形参中 b 有了，那么 c 一定要有(b往后一定要有) //在声明中形参有了默认值，在编写函数时就不能有了} 函数的占位参数 12345678void func(int a,int )//第二个为占位用的{//占位参数可以用默认参数 cout&lt;&lt;\"占位参数\"&lt;&lt;endl;}int main(){ func(10,10);//但是func(10)是不对的} 函数的重载函数重载的注意事项： 1234567891011121314151617181920212223//(1)在引用中void func(int &amp;a){ cout&lt;&lt;\"不加const \"&lt;&lt;endl;}void func(const int &amp;a){ cout&lt;&lt;\"加const 版本\"&lt;&lt;endl;}//在main中调用//int a=10;func(a);为不加const//func(10);为加const// (2) 在默认参数中void func2(int a,int b=10){ cout&lt;&lt;\"func2(int a)的调用\"&lt;&lt;endl;}void func2(int a){ cout&lt;&lt;\"func2(int a)的调用\"&lt;&lt;endl;}//在main中调用func2(8)，会出错，编译器不知道该调哪个函数 类和对象关于类分为三个部分，分别为封装、继承、多态。 1. 封装一个简单的例子： 1234567891011121314151617181920212223242526272829303132#include\"string\"class student{public: //公共权限 //类中的属性和行为都称为成员 //属性 （成员属性） string m_Name; int m_Id; //行为（成员函数） void show() { cout&lt;&lt;\"学生的姓名:\"&lt;&lt;m_Name&lt;&lt;\" 学号:\"&lt;&lt;m_Id&lt;&lt;endl; } void setName(string name) { m_Name=name; } void setId(int id) { m_Id=id; }};int main(){ class student s1; //s1.m_Name=\"张三\"; //s1.m_Id=002; s1.setName(\"张三\"); s1.setId(23); s1.show(); return 0;} 关于类的三种访问权限 public 类内可访问，类外可访问； private 类内可访问，类外不可访问； protected 类内可访问，类外不可访问 继承会用到，子类可以访问父类。 一个例子即可说明上面的三点： 123456789101112131415161718192021222324class Person{public: int m_a; void setfunc(int b) { m_b=b; } int getfunc() { return m_b; }protected: int m_b;private: int m_c;};int main(){ Person s; s.setfunc(3); cout&lt;&lt;s.getfunc()&lt;&lt;endl; return 0;} struct 和 class 的区别（默认访问权限不同）struct 为公共权限；class 为私有权限(只能在类内使用，在main中不能赋值)类的私有化成员属性的私有化的优点：1可以控制读写的权限 2读写可以检测数据的有效性 12345678910111213141516171819202122232425262728293031323334353637383940414243#include\"string\"class Person{public: void setName(string name) { m_Name=name; } string getName() { return m_Name; } void setAge(int age) { if(age&lt;0||age&gt;150) { m_Age=0; cout&lt;&lt;\"你输入的年龄有误，已经强制改为0\"&lt;&lt;endl; //return; } else m_Age=age; } int getAge() { return m_Age; } //另外两个一样private://设置私有属性，再用公共函数去调用，可以控制其读写性 string m_Name;//设置可读可写 int m_Age; string m_Lover;};int main(){ class Person p1; p1.setName(\"战三\"); p1.setAge(18); cout&lt;&lt;\"p1的名字为：\"&lt;&lt;p1.getName()&lt;&lt;endl; cout&lt;&lt;\"p1的年龄为：\"&lt;&lt;p1.getAge()&lt;&lt;endl; return 0;} 一个求立方体的体积的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142class cube{private: double m_L; double m_W; double m_H; double m_S; double m_V;public: void setL(double l) { m_L=l; } double getL() { return m_L; } void setW(double w) { if(w&lt;0) { m_W=0; cout&lt;&lt;\"你输入的数据有误，系统已转为0\"&lt;&lt;endl; return; } else { m_W=w; } } double getW() { return m_W; } void setH(double h) { if(h&lt;0) { m_H=0; cout&lt;&lt;\"你输入的数据有误，系统已转为0\"&lt;&lt;endl; return; } else { m_H=h; } } double getH() { return m_H; } double getS() { m_S=2*(m_L*m_H+m_L*m_W+m_H*m_W); return m_S; } double getV() { m_V=m_L*m_W*m_H; return m_V; } bool same1(cube &amp;a2)//成员函数判断相等 { if(m_H==a2.getH()&amp;&amp;m_L==a2.getL()&amp;&amp;m_W==a2.getW()) { return true; } else return false; }};bool same(cube &amp;a1,cube &amp;a2)//全局函数判断相等{ if(a1.getH()==a2.getH()&amp;&amp;a1.getL()==a2.getL()&amp;&amp;a1.getW()==a2.getW()) { return true; } else return false;}int main(){ class cube a1; double b,c,d; cout&lt;&lt;\"请输入立方体的长：\"; while(true) { cin&gt;&gt;b; if(b&gt;0) { a1.setL(b);break; } cout&lt;&lt;\"你输入错误，请重新输入：\"; } cout&lt;&lt;\"请输入立方体的宽：\"; cin&gt;&gt;c; a1.setW(c); cout&lt;&lt;\"请输入立方体的高：\"; cin&gt;&gt;d; a1.setH(d); cout&lt;&lt;\"立方体的面积为：\"&lt;&lt;a1.getS()&lt;&lt;endl; cout&lt;&lt;\"立方体的体积为：\"&lt;&lt;a1.getV()&lt;&lt;endl; class cube a2; double b2,c2,d2; cout&lt;&lt;\"请输入立方体的长：\"; while(true) { cin&gt;&gt;b2; if(b2&gt;0) { a2.setL(b2);break; } cout&lt;&lt;\"你输入错误，请重新输入：\"; } cout&lt;&lt;\"请输入立方体的宽：\"; cin&gt;&gt;c2; a2.setW(c2); cout&lt;&lt;\"请输入立方体的高：\"; cin&gt;&gt;d2; a2.setH(d2); cout&lt;&lt;\"立方体的面积为：\"&lt;&lt;a2.getS()&lt;&lt;endl; cout&lt;&lt;\"立方体的体积为：\"&lt;&lt;a2.getV()&lt;&lt;endl; bool ret=same(a1,a2);//利用全局函数判断相等 if(ret==1) { cout&lt;&lt;\"q两个立方体一样\"&lt;&lt;endl; } else cout&lt;&lt;\"q两个立方体不同\"&lt;&lt;endl; bool ret2=a1.same1(a2); if(ret2==1) { cout&lt;&lt;\"c两个立方体一样\"&lt;&lt;endl; } else cout&lt;&lt;\"c两个立方体不同\"&lt;&lt;endl; return 0;} 对象的初始化和清理构造函数是初始化；析构函数是清理；构造函数和析构函数都写在对象内部。 1234567891011121314151617class Person{ //1写构造函数：无返回值，无void 函数名与类名相同 //可以有参数，可发生重载，值调用一次public: Person() { cout&lt;&lt;\"Person构造函数的调用\"&lt;&lt;endl; }//在main函数中直接定义一个类，什么都不用写，也会调用这句话 //2析构函数:无返回值，无void 函数名与类同名，需要加'~' //无参数，不发生重载，对象销毁前自动调用函数，只调用一次 ~person() { cout&lt;&lt;\"person的析构函数调用\"&lt;&lt;endl; }//在main中对象销毁前自动调用 }; 构造函数的分类和调用分类：有参数和无参数，普通构造和拷贝构造调用：括号法，显示法，因式转换法 12345678910111213141516171819202122232425262728293031323334353637383940414243class Person{public: Person()//无参构造（普通构造） { cout&lt;&lt;\"person的无参构造函数的调用\"&lt;&lt;endl; } Person(int a)//有参构造（普通构造） { age=a; cout&lt;&lt;\"person的有参构造函数的调用\"&lt;&lt;endl; } Person(const Person &amp;p)//拷贝构造（其他的叫普通构造） { age=p.age;//在主函数中有个age,给他初始化，用拷贝函数 cout&lt;&lt;\"拷贝函数调用\"&lt;&lt;endl; } int age;};//构造函数的调用void test(){ // 1 括号法 Person p1;//默认构造函数的调用 Person p2(10);//有参构造函数调用 Person p3(p2);//拷贝构造函数调用 //注意：在调用默认构造函数时不要写(),直接写Person p1; cout&lt;&lt;\"p2的年龄：\"&lt;&lt;p2.age&lt;&lt;endl; cout&lt;&lt;\"p3的年龄：\"&lt;&lt;p3.age&lt;&lt;endl; //2 显示法 Person p1; Person p2=Person(10); //Person(10) 是匿名对象(对象没有名)，执行完这句话，就销毁掉了 Person p3=Person(p2); //3 隐式转换法 Person p4=10;//相当于 Person p4=Person(10);(有参构造) Person p5=p2;//调用拷贝构造}int main(){ test();} 拷贝构造函数的调用 一个已经创建完毕的对象初始化一个新的对象（克隆的作用） 值传递的方式给函数参数传值 以值方式返回局部对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Person{public: Person()//无参构造（默认构造、普通构造） { cout&lt;&lt;\"person的无参构造函数的调用\"&lt;&lt;endl; } Person(int age) { m_Age=age; cout&lt;&lt;\"person的有参构造函数的调用\"&lt;&lt;endl; } Person(const Person &amp;p) { m_Age=p.m_Age; cout&lt;&lt;\"person的拷贝构造函数的调用\"&lt;&lt;endl; } ~Person() { cout&lt;&lt;\"person的析构函数的调用\"&lt;&lt;endl; } int m_Age;};// 1 一个已经创建完毕的对象初始化一个新的对象（克隆的作用）void test1(){ Person p1; p1.m_Age=10; Person p2=p1;//p1的所有内容都给了p2 //等价于Person p2=Person(p1) cout&lt;&lt;p2.m_Age&lt;&lt;endl;}// 2 值传递的方式给函数参数传值void dowo(Person p){}void test2(){ Person p;//无参 dowo(p);//会调用拷贝构造函数}// 3 以值方式返回局部对象Person dowo2()//局部对象在函数执行完毕之后就释放掉了{ Person p1;//局部对象，执行完就销毁了 return p1;//在返回时创建一个新的对象}void test3(){ Person p=dowo2();}int main(){ //test1(); //test2(); test3();} 构造函数的调用原则 在构造一个类时，c++会给每个类添加至少三个函数； 1 默认构造函数 2 析构函数 3 拷贝函数 如果写了有参构造函数，编译器不再提供默认构造，依然提供拷贝构造；解析用上面的即可；如果写了拷贝构造函数，编译器不再提供其他构造函数123456789101112131415161718192021222324252627282930313233class Person{public: Person()//无参构造（默认构造、普通构造） { cout&lt;&lt;\"person的无参构造函数的调用\"&lt;&lt;endl; } Person(int age) { m_Age=age; cout&lt;&lt;\"person的有参构造函数的调用\"&lt;&lt;endl; } Person(const Person &amp;p) { m_Age=p.m_Age; cout&lt;&lt;\"person的拷贝构造函数的调用\"&lt;&lt;endl; } ~Person() { cout&lt;&lt;\"person的析构函数的调用\"&lt;&lt;endl; } int m_Age;};int main(){ Person p; p.m_Age=10; Person p2(p);//第一种表示方法，括号法 cout&lt;&lt;\"p2的年龄：\"&lt;&lt;p2.m_Age&lt;&lt;endl; return 0; //当类中没有拷贝构造函数时，一样可以这样实现， //说明c++本身提供拷贝构造函数(并进行了调用)} 深拷贝与浅拷贝浅拷贝：简单的赋值拷贝操作(前面已经用过的赋值操作)深拷贝：在堆区重新申请空间，进行拷贝操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Person{public: Person()//无参构造（默认构造、普通构造） { cout&lt;&lt;\"person的无参构造函数的调用\"&lt;&lt;endl; } Person(int age,int h) { m_H=new int(h);//用指针接收，定义在堆区的 m_Age=age; cout&lt;&lt;\"person的有参构造函数的调用\"&lt;&lt;endl; } Person(const Person &amp;p) { m_Age=p.m_Age; cout&lt;&lt;\"person的拷贝构造函数的调用\"&lt;&lt;endl; m_H=new int (*p.m_H); //由于下面出现的都释放一个栈区的问题 //从而重新申请另外一个栈区，两个释放不再有交集 } ~Person() { //由于堆区的数据无法自己释放， //则在该函数中让其释放 if(m_H!=NULL)//释放操作 { delete m_H; m_H=NULL; } cout&lt;&lt;\"person的析构函数的调用\"&lt;&lt;endl; } int m_Age; int *m_H;//身高，要存放到堆区，需要用指针定义};int main(){ Person p2(10,165); cout&lt;&lt;\"p2的年龄：\"&lt;&lt;p2.m_Age&lt;&lt;\" \"&lt;&lt;*p2.m_H&lt;&lt;endl; //上面的代码正确，但是下面的代码有问题 Person p(11,163);//相当于p1拷贝了p, Person p1(p);//但是在析构函数中进行了两次栈区的释放产生了问题 //根据先进后出，先释放p2 后释放 p1 cout&lt;&lt;\"p1的年龄：\"&lt;&lt;p1.m_Age&lt;&lt;\" \"&lt;&lt;*p1.m_H&lt;&lt;endl; return 0;} 初始化列表 12345678910111213141516171819202122232425262728293031//给类中的属性进行初始化class Person{public: int m_A; int m_B; int m_C; //一般情况下的有参构造函数的初始化 Person(int a,int b,int c) { m_A=a; m_B=b; m_C=c; } //构造函数初始化列表 Person():m_A(10),m_B(20),m_C(30) { } //或者下面这样可以随意的初值 Person(int a,int b,int c):m_A(a),m_B(b),m_C(c) { }};int main(){ Person p; //Person p(10,20,30);//用有参构造函数进行初始化 cout&lt;&lt;p.m_A&lt;&lt;\" \"&lt;&lt;p.m_B&lt;&lt;\" \"&lt;&lt;p.m_C&lt;&lt;endl; return 0;} 类的对象作为其他类的成员 123456789101112131415161718192021222324252627#include&lt;string&gt;class Phone{public: Phone(string pname)//有参构造函数 { m_Pname=pname; } string m_Pname;};class Person{public: Person(string name,string pname):m_Name(name),m_Phone(pname) { }//只能用这种方式的构造函数初始化 string m_Name; Phone m_Phone;//phone类中的成员};int main(){ Person p(\"张三\",\"苹果手机\"); cout&lt;&lt;p.m_Name&lt;&lt;\" 拿着 \"&lt;&lt;p.m_Phone.m_Pname&lt;&lt;endl; return 0;}//系统先运行phone的构造函数在运行person的构造函数(析构顺序相反) 静态成员所有对象共享同一函数；静态成员函数只能访问静态成员变量；静态成员函数与其他成员一样都有访问权限。 123456789101112131415161718192021222324252627class Person{public: static void func()//静态成员函数 { //m_B=200;(B不是静态，不能在这修改，原因是无法区分是哪个对象的m_B) m_A=100;//静态成员函数能改变静态成员变量 cout&lt;&lt;\"static func 函数的调用.\"&lt;&lt;endl; } static int m_A;//静态成员变量 int m_B;//普通的成员变量};int Person::m_A=0;//由于是静态成员变量，必须要初始化void test1(){ //1 使用对象访问 Person p; p.func(); //使用类名访问 Person::func();}int main(){ test1(); return 0;} 对象模型和 this 指针成员变量和成员函数分开存储（只有非静态成员变量属于类的对象）；并且静态成员函数和静态成员变量都不在成员变量中this 指针的用处： 12345678910111213141516171819202122232425262728293031323334353637// 1 解决名称冲突(形参与成员变量同名)class Person{public: Person(int age)//形参名与成员变量名相同 { (*this).age=age;//此时用this指针加以区别 }//this指针指向被调用的成员函数所属的对象 int age;//成员变量 Person&amp; PersonAdd(Person &amp;p) { (*this).age+=p.age; return *this;//变成返回对象本身，函数类型也要变成Person &amp; }};void test();int main(){ Person p(18); cout&lt;&lt;\" \"&lt;&lt;p.age&lt;&lt;endl; test(); return 0;}// 2 返回对象本身用 *this (非静态成员函数)void test(){ Person p1(10); Person p2(10); //下面叫做链式编程思想(可以无限的追加) p1.PersonAdd(p2).PersonAdd(p2);//仔细观察PersonAdd即可 //该函数把两个对象的值相加了 cout&lt;&lt;\" \"&lt;&lt;p1.age&lt;&lt;endl;} 空指针返回成员函数(需要过滤掉)： 12345678910111213141516171819202122232425262728class Person {public: void shname() { cout&lt;&lt;\"这是一个Person class\"&lt;&lt;endl; } void showage() { if(this==NULL)//开始是报错的，但是经过该操作，过滤掉了空指针 { return ; } cout&lt;&lt;\" age= \"&lt;&lt;m_Age&lt;&lt;endl;//相当于(*this).m_Age } int m_Age;};void test(){ Person *p=NULL; (*p).shname(); (*p).showage();//开始在这报错，由于传入的是空指针}int main(){ test(); return 0;} const 修饰成员函数 123456789101112131415//*****常函数的说明****class Person{public: //*this相当于person *const this，只能指向一个对象 //const person *const this,相当于下面的函数形式 //上两行指针的指向不可以修改，上一行的指针的指向的值也不可以修改 void shPe() const//加入const后就不能再修改值了 {//所以本质上修饰的是this 指针，其修饰的值也不可以修改了 (*this).m_A=100;//由于是public从而不可以修改m_A的值 (*this).m_B=100;//由于加了mutable就可以修改了 } int m_A; mutable int m_B;//这个变量，即使是常函数，也可以修改这个值} 常对象 123456789void test(){ const Person p;//对象 p 为常对象 //对于常对象的属性也是不能修改的 //但是对于加mutable 的成员是可以修改的 //p.m_B=100;正确 //常对象只能调用常函数也就是 p.shPe() 可以调用} 友元对于类内的私有对象，允许类外的一些函数和类进行访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//*************** 1 全局函数做友元*************#include&lt;string&gt;class Build{ friend void goodgay(Build &amp;p);//全局函数访问私有属性private: string m_Bed;public: string m_Siting; Build() { m_Bed=\"卧室\"; m_Siting=\"客厅\"; }};void goodgay(Build &amp;p){ cout&lt;&lt;\"外人正在访问：\"&lt;&lt;p.m_Siting&lt;&lt;endl; cout&lt;&lt;\"外人正在访问：\"&lt;&lt;p.m_Bed&lt;&lt;endl;}int main(){ Build p; goodgay(p); return 0;}//***************** 2 类做友元*************#include&lt;string&gt;class Build{ friend class Goodgay;//友元类，可以访问私有private: string m_Bed;public: string m_Siting; Build()//构造函数在类内附初值 { m_Bed=\"卧室\"; m_Siting=\"客厅\"; }};//构造函数的类外附初值//Build::Build()//{// m_Bed=\"卧室\";// m_Siting=\"客厅\";//}class Goodgay{public: Good();//构造函数，并在类外附初值 void visit(); Build *build;//创造了另一个类的指针};Goodgay::Good()//类外附初值{ //创建一个建筑物的对象 build =new Build;//堆区创建对象}void Goodgay::visit()//类的函数在类外实现{ cout&lt;&lt;\"好基友正在访问：\"&lt;&lt;build-&gt;m_Bed&lt;&lt;endl;}int main(){ Goodgay g; g.visit(); return 0;}//************* 3 成员函数做友元***********#include&lt;string&gt;class Build{//另一个类的成员函数可以访问私有成员 friend void GoodGay::visit2();//加上后可以访问私有成员public: string m_Sitting; Build();private: string m_Bed;};class GoodGay{public: GoodGay(); void visit();//可以访问Build的公共成员 void visit2();//不可以访问Build的私有成员 Build *build;};Build::Build()//类外附初值{ m_Sitting=\"客厅\"; m_Bed=\"卧室\";}GoodGay::GoodGay(){ build=new Build;}void GoodGay::visit(){ cout&lt;&lt;\"可以访问:\"&lt;&lt;build-&gt;m_Sitting&lt;&lt;endl;}void GoodGay::visit2(){ cout&lt;&lt;\"加上friend void Goodgay::visit2();可以访问:\"&lt;&lt;build-&gt;m_Bed&lt;&lt;endl;}int main(){ GoodGay g1; g1.visit(); g1.visit2(); return 0;} 运算符重载1 加号运算重载 12345678910111213141516171819202122232425262728293031class To{public: int m_A; int m_B; To operator+ (To &amp;p)//实现类内成员的相加 operator+ 是系统规定的，调用时可以直接用 + {//也就相当于运算符的重载 To temp; temp.m_A=this-&gt;m_A+p.m_A; temp.m_B=this-&gt;m_B+p.m_B; return temp; }};To operator+ (To &amp;p1,To &amp;p2){//上面是类内函数的运算符重载，下面是全局函数的重载 To temp; temp.m_A=p1.m_A+p2.m_A; temp.m_B=p1.m_B+p2.m_B; return temp;}int main(){ To p1; p1.m_A=10; p1.m_B=10; To p2; p2.m_A=10; p2.m_B=10; To p3=p1+p2;//由To p3=p1.operator +(p2)可简化为前面的式子 cout&lt;&lt;\" \"&lt;&lt;p3.m_A&lt;&lt;\" \"&lt;&lt;p3.m_B&lt;&lt;endl;} 2 重载左移运算符 123456789101112131415161718192021222324252627282930313233343536373839class Person{public: int m_A; int m_B;};void operator&lt;&lt;(ostream &amp;cout,Person &amp;p){ cout&lt;&lt;\"m_A= \"&lt;&lt;p.m_A&lt;&lt;\" m_B= \"&lt;&lt;p.m_B&lt;&lt;endl;}int main(){ Person p; p.m_A=10; p.m_B=10; cout&lt;&lt;p;//只能输出一个 &lt;&lt;，如果需要继续输出，则进行链式编程的思想 return 0;}//实现链式编程，连续重载class Person{public: int m_A; int m_B;};ostream&amp; operator&lt;&lt;(ostream &amp;cout,Person &amp;p){ cout&lt;&lt;\"m_A= \"&lt;&lt;p.m_A&lt;&lt;\" m_B= \"&lt;&lt;p.m_B; return cout;}int main(){ Person p; p.m_A=10; p.m_B=10; cout&lt;&lt;p&lt;&lt;endl;//这样修改了全局函数的返回类型，即可连续输出 &lt;&lt; return 0;} 3 递增运算符重载 123456789101112131415161718192021222324252627282930313233343536373839class MyInt{ friend ostream&amp; operator&lt;&lt;(ostream&amp; cout,MyInt myint);public: MyInt()//初始 { m_Num=0; } //前置递增（返回引用） MyInt&amp; operator++()//用取址运算符是可以连续的递增(且只对一个数据) { m_Num++; return *this; } //后置递增（返回值） MyInt operator++(int)//int 为占位参数，可以区别前置和后置 {//返回的是局部引用，运行完会释放，不能累加 //从而不能返回 &amp; MyInt temp=*this; m_Num++; return temp; }private: int m_Num;};//重载左移运算符ostream&amp; operator&lt;&lt;(ostream&amp; cout,MyInt myint){ cout&lt;&lt;myint.m_Num;//还需要用到友元，num是私有 return cout;}int main(){ MyInt myint; ostream&amp; operator&lt;&lt;(ostream&amp; cout,myint); cout&lt;&lt;myint++; return 0;} 4 赋值运算符 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Person{public: Person(int age)//构造函数 { m_Age=new int(age);//创建堆区的数据，用指针的成员去接收 } ~Person() { if(m_Age!=NULL) { delete m_Age; m_Age=NULL; } } //重载 赋值运算符(解决内存重复释放)//一个等于 void operator= (Person &amp;p) { if(m_Age!=NULL)//先判断堆区属性是否为空，先释放干净，在进行深拷贝 { delete m_Age; m_Age=NULL; } m_Age=new int(*p.m_Age); }//连等于，链式编程 Person &amp;operator= (Person &amp;p) { if(m_Age!=NULL)//先判断堆区属性是否为空，先释放干净，在进行深拷贝 { delete m_Age; m_Age=NULL; } m_Age=new int(*p.m_Age); return *this; } int *m_Age;};int main(){ Person p1(18); Person p2(20); Person p3(20); p3=p2=p1; cout&lt;&lt;*p1.m_Age&lt;&lt;endl; cout&lt;&lt;*p2.m_Age&lt;&lt;endl; cout&lt;&lt;*p3.m_Age&lt;&lt;endl; return 0;} 5 重载关系运算符（!= 和 ==） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;string&gt;class Person{public: Person(string name, int age) { m_Age=age; m_Name=name; } bool operator== (Person &amp;p) { if(this-&gt;m_Name==p.m_Name&amp;&amp; this-&gt;m_Age==p.m_Age) { return true; } else return false; } bool operator!= (Person &amp;p) { if(this-&gt;m_Name!=p.m_Name|| this-&gt;m_Age!=p.m_Age) { return true; } else return false; } string m_Name; int m_Age;};int main(){ Person p1(\"Tom\",18); Person p2(\"Tom\",19); if(p1==p2) { cout&lt;&lt;\"p1和p2是1相等的\"&lt;&lt;endl; } else { cout&lt;&lt;\"p1和p2不1相等\"&lt;&lt;endl; } if(p1!=p2) { cout&lt;&lt;\"p1和p2是不2相等的\"&lt;&lt;endl; } else { cout&lt;&lt;\"p1和p2 2相等\"&lt;&lt;endl; }} 6 重载左移运算符 123456789101112131415161718192021222324class Person{public: int m_A; int m_B; //void operator(Person &amp;p);//会涉及到两个对象，不可取};//重载左移运算符只能用全局函数，不能用成员函数void operator&lt;&lt;(ostream &amp;cout,Person &amp;p)//从而可以简化为cout&lt;&lt;p;{ cout&lt;&lt;\"m_A= \"&lt;&lt;p.m_A&lt;&lt;\" m_B= \"&lt;&lt;p.m_B&lt;&lt;endl;}int main(){ Person p; p.m_A=10; p.m_B=20; cout&lt;&lt;\" \"&lt;&lt;p;//上面的全局函数是void 时，这里不能用&lt;&lt;endl //由于链式法则，不能连续继承 //如果想继承，把全局函数的返回值类型改为ostream &amp;即可 //写上&lt;&lt;endl return 0; } 函数调用运算符重载函数调用时，用到小括号 () 它也可以发生重载；重载小括号也叫做仿函数 12345678910111213141516171819202122#include&lt;string&gt;class Print{public: void operator()(string test)//输出的重载 { cout&lt;&lt;test&lt;&lt;endl; }// int operator()(int a,int b)//加法的重载// {// return a+b;// }};int main(){ Print p; p(\"hello world\");// cout&lt;&lt;p(5,6)&lt;&lt;endl;//该调用方式，为重载的形式 //匿名函数对象// cout&lt;&lt;Print()(100,20)&lt;&lt;endl;//不想命名对象，直接输出的形式 return 0;} 2. 继承继承方式继承的代码形式 class 子类：继承方式 父类。继承方式有三种：公共继承 私有继承 保护继承：公共继承：父类中公共和保护可以继承，私有不能继承；保护继承：父类中保护的成员可以继承，公共的成员变成保护成员，私有不继承；私有继承：父类中公共和保护成员都变成私有成员都可以继承，私有不能继承。 1234567891011121314151617181920212223242526272829303132class Fa{private: int A;public: int B;protected: int C;};class Zi1:public Fa{//继承了公共的B，保护的C};class Zi2:private Fa{//继承了B C并都转为私有};class Zi3:protected Fa{//继承了B C并都变成了保护};class Zzi:public Zi1//可以多次继承，只要满足条件即可{};int main(){ Zi1 p; p.B=10; cout&lt;&lt;\" \"&lt;&lt;p.B&lt;&lt;endl; return 0;} 继承中的对象模型子类继承父类的同时，数据的内存(包括父类的私有成员)也传给了子类 12345678910111213141516171819class Base{public: int A;private: int B;protected: int c;};class Zi:public Base{public: int D;};int main(){ cout&lt;&lt;\"子类Zi的大小为：\"&lt;&lt;sizeof(Zi)&lt;&lt;endl; return 0;} 继承中的构造与析构的顺序先走父类构造—&gt;子类构造—&gt;子类析构—&gt;父类析构 123456789101112131415161718192021222324252627282930313233343536class Base{public: int A; Base() { cout&lt;&lt;\"父类的构造函数：\"&lt;&lt;endl; } ~Base() { cout&lt;&lt;\"父类的析构函数：\"&lt;&lt;endl; }private: int B;protected: int c;};class Zi:public Base{public: Zi() { cout&lt;&lt;\"子类的构造函数：\"&lt;&lt;endl; } ~Zi() { cout&lt;&lt;\"子类的析构函数：\"&lt;&lt;endl; }};int main(){ //Base p; Zi p1;//先走父类构造—&gt;子类构造—&gt;子类析构—&gt;父类析构 return 0;} 继承同名的成员处理1 父类中成员的名字与子类中的成员的名字相同时，子类的成员可以直接访问；父类中的成员需要添加作用域(子类 父类::成员) 2 同名的成员函数的处理： 1234567891011121314151617181920212223242526272829303132333435363738394041class Base{public: int A; Base() { A=6; } void To() { cout&lt;&lt;\"父类的To函数：\"&lt;&lt;endl; }private: int B;protected: int c;};class Zi:public Base{public: int A; Zi(int a) { this-&gt;A=a; } void To() { cout&lt;&lt;\"子类的To函数：\"&lt;&lt;endl; }};int main(){ Zi p(3); //Base p1; cout&lt;&lt;\"Zi类中的A= \"&lt;&lt;p.A&lt;&lt;endl &lt;&lt;\"Base类中的B= \"&lt;&lt;p.Base::A&lt;&lt;endl;//父类中同名成员调用 p.To(); p.Base::To();//父类中的同名成员函数的调用 return 0;} 继承同名的静态成员的处理方式该处理方式与普通的同名成员函数相同： 12345678910111213141516171819202122232425262728293031323334353637383940class Base{public: static int m_A; static void func() { cout&lt;&lt;\"Base下的静态函数\"&lt;&lt;endl; }};int Base::m_A=100;class Zi:public Base{public: static int m_A; static void func() { cout&lt;&lt;\"Zi下的静态函数\"&lt;&lt;endl; }};int Zi::m_A=200;int main(){ // 1 通过对象的方式访问 cout&lt;&lt;\"通过对象的方式访问：\"&lt;&lt;endl; Zi p; p.Base::func();//函数 cout&lt;&lt;\"父类：\"&lt;&lt;p.Base::m_A&lt;&lt;endl; p.func();//函数 cout&lt;&lt;\"子类：\"&lt;&lt;p.m_A&lt;&lt;endl; // 2 通过类名的方式访问 cout&lt;&lt;\"通过类名的方式访问：\"&lt;&lt;endl; Zi::func(); cout&lt;&lt;\"子类：\"&lt;&lt;Zi::m_A&lt;&lt;endl; Zi::Base::func(); //第一个 :: 是用类名访问，第二个::是访问作用域下的类名 cout&lt;&lt;\"父类：\"&lt;&lt;Zi::Base::m_A&lt;&lt;endl; return 0;} 多继承语法一个子类可以继承多个父类，语法形式： class 子类：继承方式 父类1 , 继承方式 父类2…. 12345678910111213141516171819202122232425262728293031class Base1{public: int A; int B; int c; Base1() { A=5; }};class Base2{public: int A; Base2() { A=4; }};class Zi:public Base1,public Base2//语法的形式{public: int D;};int main(){ Zi p; cout&lt;&lt;\" \"&lt;&lt;p.Base1::A&lt;&lt;\" \"&lt;&lt;p.Base2::A&lt;&lt;endl; return 0;} 菱形继承（钻石继承） 123456789101112131415161718192021222324252627282930class Animal //加上virtual 之后就是虚继承，此类称为虚基类{public: int m_Age;};//羊类class Sheep : virtual public Animal{};//驼类class Tuo : virtual public Animal//虚继承 加virtual{};//羊驼类class SheepTuo:public Sheep,public Tuo//虚继承加 virtual {};int main(){ SheepTuo p; p.Sheep::m_Age=10; p.Tuo::m_Age=20; cout&lt;&lt;p.Sheep::m_Age&lt;&lt;endl;//但是出现问题，羊驼到底多少岁？ cout&lt;&lt;p.Tuo::m_Age&lt;&lt;endl;//从而利用虚继承解决菱形继承问题 cout&lt;&lt;p.m_Age&lt;&lt;endl;//加了虚继承以后可以直接这样调用 return 0;} 多态多态的分类： 静态多态：函数重载和运算符重载都为静态多态；静态多态的函数地址早绑定，编译阶段确定函数地址 动态多态：派生类和虚函数实现运行的多态；动态多态的函数地址晚绑定，运行阶段确定函数地址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//早绑定的例子class Animal{public: void speak() { cout&lt;&lt;\"动物说话\"&lt;&lt;endl; }};class Cat:public Animal{public: void speak() { cout&lt;&lt;\"猫会说话\"&lt;&lt;endl; }};void Dospeak(Animal &amp;animal){ animal.speak();}int main(){ Cat p; Dospeak(p);//会输出 动物会说话 //原因是：地址早绑定，编译阶段确定函数地址}//动态多态函数，晚绑定的例子//动态多态的满足条件：有继承关系，子类重写父类的虚函数//重写的所有内容都一样，除了 {} 内的内容class Animal{public: virtual void speak()//虚函数 { cout&lt;&lt;\"动物说话\"&lt;&lt;endl; }};class Cat:public Animal{public: void speak() { cout&lt;&lt;\"猫会说话\"&lt;&lt;endl; }};class Dog:public Animal{public: void speak() { cout&lt;&lt;\"狗会说话\"&lt;&lt;endl; }};void Dospeak(Animal &amp;animal)//父类的指针或引用执行子类的对象{ animal.speak();//发生多态，去调用了子类的函数}int main(){ Cat p;Dog q; Dospeak(p);//在运行的时候才绑定，输出猫会说话 Dospeak(q);} 多态的底层原理 12345678910class Animal{public: virtual void speak()//虚函数 { cout&lt;&lt;\"动物说话\"&lt;&lt;endl; }};//对于这个类：没有加virtual 占1个字节//加上virtual 之后占4个字节，相当于一个指针vfptr//vfptr的含义为virtual function pointer 计算器案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;string&gt;class Mycal{public: int m_A; int m_B;// Mycal()// {// m_A=20;// m_B=10;// } virtual int suan() { return 0; }};class Myadd:public Mycal{public: int suan() { return m_A+m_B; }};class Myjian:public Mycal{public: int suan() { return m_A-m_B; } };class Mycheng:public Mycal{public: int suan() { return m_A*m_B; } };class Myyu:public Mycal{public: int suan() { return m_A%m_B; }};//int Dowork(Mycal &amp;p)//{// int c=p.suan();// return c;//}int main(){ string s; cout&lt;&lt;\"你想做那种运算: \"; cin&gt;&gt;s; if(s==\"+\") { Mycal *p=new Myadd;//指针指向子类对象 cout&lt;&lt;\"请输入要做运算的两个数：\"; cin&gt;&gt;p-&gt;m_A&gt;&gt;p-&gt;m_B; cout&lt;&lt;p-&gt;m_A&lt;&lt;\" + \"&lt;&lt;p-&gt;m_B&lt;&lt;\" =\"&lt;&lt;p-&gt;suan()&lt;&lt;endl; delete p; } else if(s==\"-\") { Mycal *p=new Myjian;//指针指向子类对象 cout&lt;&lt;\"请输入要做运算的两个数：\"; cin&gt;&gt;p-&gt;m_A&gt;&gt;p-&gt;m_B; cout&lt;&lt;p-&gt;m_A&lt;&lt;\" - \"&lt;&lt;p-&gt;m_B&lt;&lt;\" =\"&lt;&lt;p-&gt;suan()&lt;&lt;endl; delete p; } else if(s==\"*\") { Mycal *p=new Mycheng;//指针指向子类对象 cout&lt;&lt;\"请输入要做运算的两个数：\"; cin&gt;&gt;p-&gt;m_A&gt;&gt;p-&gt;m_B; cout&lt;&lt;p-&gt;m_A&lt;&lt;\" * \"&lt;&lt;p-&gt;m_B&lt;&lt;\" =\"&lt;&lt;p-&gt;suan()&lt;&lt;endl; delete p; } else if(s==\"%\") { Mycal *p=new Myyu;//指针指向子类对象 cout&lt;&lt;\"请输入要做运算的两个数：\"; cin&gt;&gt;p-&gt;m_A&gt;&gt;p-&gt;m_B; cout&lt;&lt;p-&gt;m_A&lt;&lt;\" % \"&lt;&lt;p-&gt;m_B&lt;&lt;\" =\"&lt;&lt;p-&gt;suan()&lt;&lt;endl; delete p; }// Mycal *p=new Myadd;// Myadd p1;// Myjian p2;Mycheng p3;// cout&lt;&lt;\"加 \"&lt;&lt;Dowork(p1)&lt;&lt;endl;// cout&lt;&lt;\"减 \"&lt;&lt;Dowork(p2)&lt;&lt;endl;// cout&lt;&lt;\"乘 \"&lt;&lt;Dowork(p3)&lt;&lt;endl; return 0;} 纯虚函数和抽象类 123456789101112131415161718192021222324252627282930313233343536class Animal{public: virtual void speak()//虚函数 { cout&lt;&lt;\"动物说话\"&lt;&lt;endl; }//在这个函数中整个运算过程用不到这个函数的输出 //从而可以改为纯虚函数，形式为 virtual void speak()=0;};//在类中只要有纯虚函数，那么这个类叫做抽象类//子类必须重写父类的纯虚函数class Cat:public Animal{public: void speak() { cout&lt;&lt;\"猫会说话\"&lt;&lt;endl; }};class Dog:public Animal{public: void speak() { cout&lt;&lt;\"狗会说话\"&lt;&lt;endl; }};void Dospeak(Animal &amp;animal){ animal.speak();}int main(){ Cat p;Dog q; Dospeak(p); Dospeak(q);} 案例：饮品的制作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Drink{public: virtual void Boil()=0; virtual void Pao()=0; virtual void Pull()=0; virtual void Add()=0;};class Coffee:public Drink{public: void Boil() { cout&lt;&lt;\"第一步：煮水 \"&lt;&lt;endl; } void Pao() { cout&lt;&lt;\"第二步：冲泡咖啡 \"&lt;&lt;endl; } void Pull() { cout&lt;&lt;\"第三步：倒入杯中 \"&lt;&lt;endl; } void Add() { cout&lt;&lt;\"第四步：加糖和牛奶 \"&lt;&lt;endl; }};class Tea:public Drink{public: void Boil() { cout&lt;&lt;\"第一步：煮水 \"&lt;&lt;endl; } void Pao() { cout&lt;&lt;\"第二步：冲泡茶叶 \"&lt;&lt;endl; } void Pull() { cout&lt;&lt;\"第三步：倒入杯中 \"&lt;&lt;endl; } void Add() { cout&lt;&lt;\"第四步：加柠檬 \"&lt;&lt;endl; }};void DoDrink1(Drink &amp;p)//引用的调用方式{ p.Boil(); p.Pao(); p.Pull(); p.Add();}void DoDrink2(Drink *p){ p-&gt;Boil(); p-&gt;Pao(); p-&gt;Pull(); p-&gt;Add(); delete p;//堆区的数据释放}int main(){ Coffee a; Tea b; cout&lt;&lt;\"咖啡的制作过程(引用写法)：\"&lt;&lt;endl; DoDrink1(a); cout&lt;&lt;\"************（指针写法）\"&lt;&lt;endl; DoDrink2(new Coffee); cout&lt;&lt;\"茶的制作过程(引用写法)：\"&lt;&lt;endl; DoDrink1(b); cout&lt;&lt;\"************（指针写法）\"&lt;&lt;endl; DoDrink2(new Tea); return 0;} 虚析构和纯虚析构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;string&gt;class Animal{public: virtual void Speak()=0; virtual ~Animal() { cout&lt;&lt;\"动物的析构函数\"&lt;&lt;endl; }//虚析构解决子类的析构不能释放的问题 //有时不用析构打印数据，直接写成纯虚析构 //用于打印子类的析构函数，形式：virtual ~Animal()=0; //但是会报错，需要在类的外面加上 //Animal::~Animal(){},才会正确};class Cat :public Animal{public: void Speak() { cout&lt;&lt;*m_Name&lt;&lt;\"小猫会说话。\"&lt;&lt;endl; } Cat(string name)//构造函数 { cout&lt;&lt;\"Cat的构造函数\"&lt;&lt;endl; m_Name=new string(name);//堆区创建，但没有释放 } ~Cat()//在析构函数中释放 { if(m_Name!=NULL) { cout&lt;&lt;\"Cat的析构函数\"&lt;&lt;endl; delete m_Name; m_Name=NULL; }//如果父类的析构不加virtual 则子类的析构不能实现 } string *m_Name;//定义指针变量};//void speak(Animal *p)//{// p-&gt;Speak();// delete p;//}int main(){ Animal *p=new Cat(\"Tom\");//在创建时，并重新命名 p-&gt;Speak(); delete p; return 0;} c++的提高篇模板模板是：建立通用的模具，提高复用性（不可以直接使用，通用并不代表万能）；泛型编程用的是模板：有函数模板和类模板两种 函数模板函数模板(关键词：template；申明一个模板，T为通用的数据类型) 1234567891011121314template&lt;typename T&gt;//T为想要交换的类型void mySwap(T &amp;a,T &amp;b)//可以实现多种类型的交换{ T temp=a; a=b; b=temp;}int main(){ int a=5,b=3; mySwap(a,b);//自动类型推导的交换或者显示指定类型用mySwap&lt;int&gt;(a,b) cout&lt;&lt;\"a= \"&lt;&lt;a&lt;&lt;\" b= \"&lt;&lt;b&lt;&lt;endl; return 0;} 函数模板的案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586int main(){ int a[5]={1,5,6,8,2},temp; for(int i=0;i&lt;4;i++) { for(int j=0;j&lt;4-i;j++) { if(a[j]&gt;a[j+1]) { temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; } } } cout&lt;&lt;\"**************\"&lt;&lt;endl; for(int h=0;h&lt;5;h++) { cout&lt;&lt;a[h]&lt;&lt;endl; } return 0;}template&lt;typename T&gt;void pai(T a[],int len)// 冒泡排序法{ //a[AB]={5,3,6,4,1,2}; for(int i=0;i&lt;len-1;i++) { for(int j=0;j&lt;len-1-i;j++) { if(a[j]&gt;a[j+1]) { T temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; } } }}//上面是冒泡排序法，下面是选择排序法template&lt;typename T&gt;void pai(T a[],int len){ for(int i=0;i&lt;len;i++) { int max=i;//认定最大值的下标 for(int j=i+1;j&lt;len;j++) {//max比j要小，从而j为最大值 if(a[max]&lt;a[j]) { max=j; } } if(max!=i) { T temp=a[max]; a[max]=a[i]; a[i]=temp; } }}template&lt;typename T&gt;void print(T a[],int len){ for(int k=0;k&lt;len;k++) { cout&lt;&lt;a[k]&lt;&lt;endl; }}void test(){ char a[]=\"badgcvne\"; int num=sizeof(a)/sizeof(char); pai(a,num); print(a,num); }int main(){ test(); return 0;} 普通函数与函数模板的区别 普通函数调用可以发生隐式类型转换 函数模板用自动类型推导（函数名(形参，形参)）,不发生隐式类型转换 函数模板用显示指定类型（函数名(形参，形参)）,发生隐式类型转换 1234567891011121314//关于隐式类型转换int Add(int a,int b){ return a+b;}int main(){ int a=5,b=3; char c='c';//隐式类型转换就是：不同类型会转成同一类型 //c的ASDII为99，a=97 cout&lt;&lt;\"a+b= \"&lt;&lt;Add(a,b)&lt;&lt;endl; cout&lt;&lt;\"a+c= \"&lt;&lt;Add(a,c)&lt;&lt;endl; return 0;} 普通函数和函数模板的调用规则 普通函数和函数模板都可实现，普通函数优先调用 通过空模板参数列表来强制调用函数模板 函数模板也可以发生重载 函数模板可产生更好的匹配，优先调用函数模板123456789101112131415161718void print(int a,int b){ cout&lt;&lt;\"调用普通函数\"&lt;&lt;endl;}template&lt;typename T&gt;void print(T a,T b){ cout&lt;&lt;\"调用函数模板\"&lt;&lt;endl;}int main(){ int a=5,b=6; //print(a,b); print&lt;&gt;(a,b);//空模板列表强制调用函数模板 return 0;}//第4点：当实参的列表可由函数列表更好的调用时，选函数模板 模板的局限性只能对系统类型进行比较，想对自定义类型，之前学过一种(运算符重载)，接下来介绍第二种： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;string&gt;class Person//******创建类{public: Person(string name,int age) { this-&gt;m_Name=name; this-&gt;m_age=age; } string m_Name; int m_age;};template&lt;typename T&gt;bool compare(T &amp;a,T &amp;b)//写函数模板{ if(a==b) { return true; } else { return false; }}//对于自定义的数据类型的处理办法//利用具体化的Person的版本实现代码，优先调用template&lt;&gt; bool compare(Person &amp;p1,Person &amp;p2){//模板的重载版本 if(p1.m_age==p2.m_age&amp;&amp;p1.m_Name==p2.m_Name) { return true; } else { return false; }}int main(){ Person p1(\"Tom\",10); Person p2(\"Tom\",10); bool ret =compare(p1,p2); if(ret) { cout&lt;&lt;\"p1和p2相同\"&lt;&lt;endl; } else { cout&lt;&lt;\"p1与p2不同\"&lt;&lt;endl; } return 0;} 类模板建立通用的类，成员的数据类型不具体制定 1234567891011121314151617181920212223#include&lt;string&gt;template&lt;class NameType,class AgeType&gt;class Person{public: NameType m_Name; AgeType m_Age; Person(NameType name,AgeType age) { this-&gt;m_Name=name; this-&gt;m_Age=age; } void print() { cout&lt;&lt;this-&gt;m_Name&lt;&lt;\" \"&lt;&lt;this-&gt;m_Age&lt;&lt;endl; }};int main(){ Person&lt;string,int&gt; p1(\"孙悟空\",545);//&lt;&gt;里边的称为模板参数列表 p1.print(); return 0;} 类模板与函数模板的区别 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;string&gt;template&lt;class NameType,class AgeType&gt;class Person{public: NameType m_Name; AgeType m_Age; Person(NameType name,AgeType age) { this-&gt;m_Name=name; this-&gt;m_Age=age; } void print() { cout&lt;&lt;this-&gt;m_Name&lt;&lt;\" \"&lt;&lt;this-&gt;m_Age&lt;&lt;endl; }};//类模板没有自动类型推导使用方式void test1(){ //Person p(\"辅导班\",48);(这种形式错误，无法自动推导) Person&lt;string,int&gt; p1(\"输出\",453); p1.print();}//类模板在模板参数列表中可以有默认参数void test2(){ //在最上面修改成template&lt;class NameType,class AgeType=int&gt; Person&lt;string&gt; p1(\"输出\",453); p1.print();}int main(){ test2(); return 0;} 类模板中成员函数创建时机普通类中成员函数一开始就创建（类模板中成员函数在调用时创建） 1234567891011121314151617181920212223242526272829303132class Person1{public: void print1() { cout&lt;&lt;\"展示Person1\"&lt;&lt;endl; }};class Person2{public: void print2() { cout&lt;&lt;\"展示Person2\"&lt;&lt;endl; }};template&lt;class T&gt;class Class{public: T a; void func1() { a.print1();//在这里并没有创建，在运行的时候才开始创建 } void func2() { a.print2(); }}; 类模板对象做函数参数类模板实例化的对象，向函数传参数的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;string&gt;template &lt;class T1,class T2&gt;class Person{ public: Person(T1 name,T2 age) { this-&gt;m_Name=name; this-&gt;m_Age=age; } T1 m_Name; T2 m_Age; void classprint() { cout&lt;&lt;this-&gt;m_Name&lt;&lt;\" \"&lt;&lt;this-&gt;m_Age&lt;&lt;endl; }};// 1 指定传入的类型(对象做函数参数)void print1(Person&lt;string,int&gt;&amp;p)//对象做函数参数{ p.classprint();//通过对象调用类的函数}void test1(){ Person&lt;string,int&gt;p(\"重孙女\",61);//可以直接p.print(), print1(p);//再调用函数}// 2 参数模板化template &lt;class T1,class T2&gt;void print2(Person&lt;T1,T2&gt;&amp;p)//原来里边具体的变为抽象的{ p.classprint(); cout&lt;&lt;\"T1的具体的数据类型：\"&lt;&lt;typeid(T1).name()&lt;&lt;endl; cout&lt;&lt;\"T2的具体的数据类型：\"&lt;&lt;typeid(T2).name()&lt;&lt;endl; //上面两行是输出具体的数据类型}void test2(){ Person&lt;string,int&gt;p(\"吃顿饭\",59); print2(p);}// 3 整个类的模板化template&lt;class T&gt;void print(T &amp;p){ p.classprint();}void test3(){ Person&lt;string,int&gt;p(\"使得\",64); print(p);}int main(){ //test1(); //test2(); test3(); return 0;} 类模板与继承子类继承的父类是一个类模板，子类在声明时，要指定出父类的类型 12345678910111213141516template&lt;class T&gt;class Base{ T m;};//class Son: public Base//必须知道父类中的T类型，才能继承class Son:public Base&lt;int&gt;{//这样定义的话，父类中只能是int};//如果想灵活指定父类T的类型，子类也应该为类模板template&lt;class T,class T1&gt;class Son1:public Base&lt;T&gt;{ T1 n;} 类模板成员函数类外实现 123456789101112131415161718192021222324252627282930#include&lt;string&gt;template&lt;class T1,class T2&gt;class Person{public: Person(T1 name,T2 age)//构造函数的类内实现 { this-&gt;m_Name=name; this-&gt;m_Age=age; } T1 m_Name; T2 m_Age; void print()//成员函数的类内实现 { cout&lt;&lt;\"姓名：\"&lt;&lt;m_Name&lt;&lt;\" 年龄：\"&lt;&lt;m_Age&lt;&lt;endl; }};template&lt;class T1,class T2&gt;Person&lt;T1,T2&gt;::Person(T1 name,T2 age)//构造函数的类外实现,类内只有Person(T1 name,T2 age);{ this-&gt;m_Name=name; this-&gt;m_Age=age;}template&lt;class T1,class T2&gt;Person&lt;T1,T2&gt;::print()//成员函数的类外实现,类内只有print();{ cout&lt;&lt;\"姓名：\"&lt;&lt;m_Name&lt;&lt;\" 年龄：\"&lt;&lt;m_Age&lt;&lt;endl;} 类模板的成员函数的分文件编写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;string&gt;template&lt;class T1,class T2&gt;class Person{public: T1 m_Name; T2 m_Age; Person(T1 name,T2 age) { this-&gt;m_Name=name; this-&gt;m_Age=age; } void print() { cout&lt;&lt;\"姓名：\"&lt;&lt;m_Name&lt;&lt;\" 年龄：\"&lt;&lt;m_Age&lt;&lt;endl; }};//template&lt;class T1,class T2&gt;//Person&lt;T1,T2&gt;::Person(T1 name,T2 age)//构造函数的类外实现//{// this-&gt;m_Name=name;// this-&gt;m_Age=age;//}int main(){ Person&lt;string,int&gt;p(\"如果他人吧\",55); p.print(); return 0;}//分文件写 在person.h中#pragma once //防止头文件重复包含#include&lt;iostream&gt;using namespace std;#include&lt;string&gt;template&lt;class T1,class T2&gt;class Person{public: T1 m_Name; T2 m_Age; Person(T1 name,T2 age); void print();};//分文件 person.cpp中#include\"person.h\"template&lt;class T1,class T2&gt;Person&lt;T1,T2&gt;::Person(T1 name,T2 age)//构造函数的类外实现{ this-&gt;m_Name=name; this-&gt;m_Age=age;}//注意在主文件中，在包含头文件#include\"person.h\"//但是编译器没有办法传入person.cpp中的内容，会编译不通过(类模板函数开始不会创建，运行才会创建)//如果在主文件中包含#include\"person.cpp\"那么就解决了这个问题//第二种解决方法是把 .cpp 文件和 .h文件写在一起，改成.hpp文件(一看就知道是类模板文件)//(第二种常用) 类模板和友元类模板配合友元函数的类内和类外实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//建议使用类内#include&lt;string&gt;template&lt;class T1,class T2&gt;class Person{ //全局函数的类内实现 friend void print(Person&lt;T1,T2&gt;p) {//全局函数 作为友元，并访问类内的私有成员 cout&lt;&lt;\"姓名：\"&lt;&lt;p.m_Name&lt;&lt;\" 年龄：\"&lt;&lt;p.m_Age&lt;&lt;endl; }public: Person(T1 name,T2 age) { this-&gt;m_Name=name; this-&gt;m_Age=age; }private: T1 m_Name; T2 m_Age;};void test1()//全局函数的类内实现{ Person&lt;string,int&gt;p(\"发的v\",45); print(p);}int main(){ test1(); return 0;}//类外实现#include&lt;string&gt;template&lt;class T1,class T2&gt;class Person{ friend void print2(Person&lt;T1,T2&gt;p); public: //friend void print2(Person&lt;T1,T2&gt;p); Person(T1 name,T2 age) { this-&gt;m_Name=name; this-&gt;m_Age=age; } private: T1 m_Name; T2 m_Age;};template&lt;class T1,class T2&gt;void print2(Person&lt;T1,T2&gt;p){ cout&lt;&lt;\"输出：\"&lt;&lt;p.m_Name&lt;&lt;\" 输出：\"&lt;&lt;p.m_Age&lt;&lt;endl;}int main(){ Person&lt;string,int&gt;p(\"ffd\",20); print2(p); return 0;} 标准数据库（STL）STL包括容器，算法，迭代器；算法与容器通过迭代器无缝连接；STL中的所有代码都可以采用类的模板和函数的模板。STL的六大组件：容器，算法，迭代器，仿函数，适配器，空间配置器。其作用分别为： 容器：各种数据结构，如vector list deque set map等存放数据 算法：sort find copy for_each 迭代器：算法与容器的链接 仿函数：行为类似函数，作为算法的某种策略 适配器：修饰容器、仿函数、迭代器的接口 空间配置器：负责空间配置和管理vector 容器容器为：vector算法为：for_each(遍历)迭代器：vector::iterator12345678910111213141516171819202122232425262728293031323334353637#include&lt;vector&gt; // 加入 vector 的头文件#include&lt;algorithm&gt;//算法的头文件void print(int val){ cout&lt;&lt;val&lt;&lt;endl;}void test1(){ vector&lt;int&gt; v;//创建一个vector的容器，数组 //向容器中插入数组 v.push_back(10);//尾插的方式 v.push_back(20); v.push_back(30); v.push_back(40); //通过迭代器访问容器中的数据 vector&lt;int&gt;::iterator itBegin=v.begin();//起始迭代器 指向容器的第一个元素 vector&lt;int&gt;::iterator itEnd=v.end();//结束迭代器 指向容器中最后一个元素的下一个位置 //第一种遍历方法 while(itBegin!=itEnd) { cout&lt;&lt;*itBegin&lt;&lt;endl; itBegin++; } //第二种遍历方式 for(vector&lt;int&gt;::iterator it=v.begin();it!=end();it++) { cout&lt;&lt;*it&lt;&lt;endl; } //第三种遍历方式 利用STL中的遍历算法（需要加头文件#include&lt;algorithm&gt;） for.each(v.begin(),v.end(),print);//print没有参数，是因为利用了回调的方式}int main(){ test1(); return 0;} vector 存放自定义的数据类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;vector&gt;#include&lt;string&gt;class Person{public: Person(string name,int age) { this-&gt;m_Name=name; this-&gt;m_Age=age; } string m_Name; int m_Age;};void test1()//存放数据{ vector&lt;Person&gt;v; Person p1(\"aaa\",10);//构造函数的附初值 Person p2(\"bbb\",20); Person p3(\"ccc\",30); Person p4(\"ddd\",40); //在容器中添加数据 v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); for(vector&lt;Person&gt;::iterator it=v.begin();it!=v.end();it++) { cout&lt;&lt;\"姓名：\"&lt;&lt;it-&gt;m_Name&lt;&lt;\" 年龄：\"&lt;&lt;it-&gt;m_Age&lt;&lt;endl; }}void test2()//存放自定义数据类型 指针{ vector&lt;Person*&gt;v; Person p1(\"aaa1\",10);//构造函数的附初值 Person p2(\"bbb1\",20); Person p3(\"ccc1\",30); Person p4(\"ddd1\",40); //在容器中添加数据 v.push_back(&amp;p1); v.push_back(&amp;p2); v.push_back(&amp;p3); v.push_back(&amp;p4); //遍历容器 for(vector&lt;Person*&gt;::iterator it=v.begin();it!=v.end();it++) { cout&lt;&lt;\"姓名：\"&lt;&lt;(*it)-&gt;m_Name&lt;&lt;\" 年龄：\"&lt;&lt;(*it)-&gt;m_Age&lt;&lt;endl; }}int main(){ //test1(); test2(); return 0;} vector 容器嵌套容器 12345678910111213141516171819202122232425262728293031#include&lt;vector&gt;#include&lt;string&gt;int main(){ vector&lt; vector&lt;int&gt; &gt;v;//一定要有int&gt; &gt;空格 vector&lt;int&gt; v1; vector&lt;int&gt; v3; vector&lt;int&gt; v2; v1.push_back(10); v1.push_back(20); v2.push_back(30); v2.push_back(40); v3.push_back(50); v3.push_back(60); v.push_back(v1); v.push_back(v2); v.push_back(v3); for(vector&lt; vector&lt;int&gt; &gt;::iterator it=v.begin();it!=v.end();it++) { for(vector&lt;int&gt;::iterator vit=(*it).begin();vit!=(*it).end();vit++) { cout&lt;&lt;*vit&lt;&lt;\" \"; } cout&lt;&lt;endl; } return 0;} string 的构造函数string();创建一个空字符串string(const char* s);用字符串 s 初始化string(const string&amp; str);使用string 对象初始化另一个string对象string(int n, char c);产生n 个c 1234567891011#include&lt;string&gt;int main(){ //const char* str=\"hello\";//字符串初始化 //string s(str); //const string&amp; str=\"csdc\";//string 初始化 //string s(str); string s(3,'s');//产生 n 个 s cout&lt;&lt;s&lt;&lt;endl; return 0;} string 的赋值操作 123456789101112131415161718 string&amp; operator=(const char* s) string&amp; operator=(const string &amp;s) string&amp; operator=(char c) string&amp; assign(const char *s)//成员函数 string&amp; assign(const char *s,int n)//将字符串的前n个输出 string&amp; assign(const string *s) string&amp; assign(int n, char c)#include&lt;string&gt;int main(){ string str1; str1.assign(\" hello \",18); cout&lt;&lt;str1&lt;&lt;endl; string str2; str2.assign(str1);//倒数第二种赋值操作 cout&lt;&lt;str2&lt;&lt;endl; return 0;} string 字符串拼接 123456789101112131415161718192021string&amp; operator+=(const char* str)string&amp; operator+=(const char c)string&amp; operator+=(const string&amp; str)string&amp; append(const char *s)string&amp; append(const char *s,int n)//把s 的前个字符加上去string&amp; append(const string &amp;s)string&amp; append(const string &amp;s,int pos, int n)//从pos 开始的n个字符#include&lt;string&gt;int main(){ string str1=\"vfvs+\"; str1+=\"sdcn\"; str1+='c'; str1+=str1; cout&lt;&lt;str1&lt;&lt;endl; str1.append(\"dfv+\"); str1.append(\"ccsdfdv\",3); //str1.append() return 0;} string 的查找和替换 12345678910int find(const string&amp; str,int pos=0) const//从开始查找pos第一次出现的地方int find(const char* s,int pos=0) const//从开始查找pos第一次出现的地方int find(const char* s,int pos, int n) const//从pos位置查找s的前n个字符第一次出现的位置int find(const char c,int pos=0) const//查找字符c的第一次出现的位置int rfind(const string&amp; str,int pos=npos) const//查找从pos,最后一次出现的位置int rfind(const char* s,int pos=npos) const//查找从pos,最后一次出现的位置int rfind(const char* s,int pos,int n) const//从pos查找前n个字符最后一次的位置int rfind(const char c,int npos=0) const//查找c最后一次出现的位置string&amp; replace(int pos,int n,const string&amp; str)//替换从pos开始n 个字符为字符串strstring&amp; replace(int pos,int n,const char* s)//替换从pos开始n 个字符为字符串s 1234567891011#include&lt;string&gt;int main(){ string str=\"abcdaaadda\"; //int pos=str.find(\"dd\");//从开始查找 int pos=str.rfind(\"dd\");//从末尾查找 //cout&lt;&lt;pos&lt;&lt;endl;//从0开始，没有返回-1 str.replace(2,1,\"df\");//从 3 位置,替换一个字符为df cout&lt;&lt;str&lt;&lt;endl; return 0;} string 的深入了解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//****************string 的字符串的比较**************#include&lt;string&gt;int main(){ string str=\"abcd\"; int slo=str.compare(\"abce\");//左=右返回0，左&gt;右返回1，左&lt;右返回-1 cout&lt;&lt;slo&lt;&lt;endl; return 0;}//***************string的字符存取*********#include&lt;string&gt;int main(){ string str=\" hello\"; //通过 []访问str中的每个字符 for(int i=0;i&lt;str.size();i++) { cout&lt;&lt;str[i]&lt;&lt;\" \"; } cout&lt;&lt;endl; //通过at函数进行访问 for(int j=0;j&lt;str.size();j++) { cout&lt;&lt;str.at(j)&lt;&lt;\" \"; } cout&lt;&lt;endl; return 0;}//********string的插入和删除**********#include&lt;string&gt;int main(){ string str=\"dvfvf\"; //str.insert(3,\"zz\");//在3号位置插入zz str.erase(2,3);//删除2号位置以后的三个字符 cout&lt;&lt;str&lt;&lt;endl; return 0;}//***********string 的子串获取*************#include&lt;string&gt;int main(){ string str=\"hello\"; string subs=str.substr(2,3);//从第二个开始截取三个字符 cout&lt;&lt;subs&lt;&lt;endl; return 0;} vector 与数组的区别以及初始化vector与数组的区别：vector可以动态扩展，数组不可以vector v;//默认构造初始化vector(v.begin(),v.end())//在[begin,end)区间内的函数vector(n,elem)//将n个elem给其本身vector(const vector &amp;vec)//拷贝构造函数 12345678910111213141516171819202122232425#include&lt;vector&gt;void print(vector&lt;int&gt; &amp;v){ for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; } cout&lt;&lt;endl;}int main(){ vector&lt;int&gt; v1;//第一种 for(int i=0;i&lt;10;i++) { v1.push_back(i); } print(v1); vector&lt;int&gt; v2(v1.begin(),v1.end());//第二种方法，直接传入v1的数据 print(v2); vector&lt;int&gt; v3(5,20);//第三种5 个20 print(v3); vector&lt;int&gt; v4(v3);//第四种直接拷贝v3的数据 print(v4); return 0;} vector 的赋值 12345678910111213141516171819202122232425262728293031#include&lt;vector&gt;void print(vector&lt;int&gt;&amp; v){ for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; } cout&lt;&lt;endl;}int main(){ vector&lt;int&gt; v1; for(int i=0;i&lt;10;i++) { v1.push_back(i); } print(v1); //1 赋值操作 = vector&lt;int&gt; v2; v2=v1; print(v2); //2 赋值操作 assign vector&lt;int&gt; v3; v3.assign(v1.begin(),v1.end());//[) print(v3); //3 赋值操作 assign vector&lt;int&gt; v4; v4.assign(5,8);//输出5 个8 print(v4); return 0;} vector容器大小empty()判断是否为空capacity()判断容器的容量size()判断元素的个数resize(int num)重新定义容器的长度resize(int num,elem)重新定义长度，多出来的补elem 1234567891011121314151617181920#include&lt;vector&gt;void print(vector&lt;int&gt;v){ for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; } cout&lt;&lt;endl;}int main(){ vector&lt;int&gt;v1; for(int i=0;i&lt;10;i++) { v1.push_back(i); } v1.resize(15,1); print(v1); return 0;} vector 的插入与删除push_back()尾部插入pop_back()删除最后一个元素insert(const_iterator pos,ele)在pos 位置插入eleinsert(const_iterator pos,a,ele)在pos位置插入a个eleerase(const_iterator pos)删除pos的位置元素erase(const_iterator start,const_iterator end)从start到endclear() 123456789101112131415161718192021222324#include&lt;vector&gt;void print(vector&lt;int&gt;v){ for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; } cout&lt;&lt;endl;}int main(){ vector&lt;int&gt;v1; for(int i=0;i&lt;10;i++) { v1.push_back(i); } print(v1); v1.pop_back(); print(v1); //在开始的位置插入9 (v1.begin(),3,5)插入3个5 v1.insert(v1.begin(),9);//一定是迭代器的形式 v1.begin() print(v1); return 0;} vector 的数据存取和string一样有两种读取方式 v[i] 和v.at(i)；v.front()第一个元素 v.back()最后一个元素vector 的互换器 swap() 1234567891011121314151617181920212223242526272829#include&lt;vector&gt;void print(vector&lt;int&gt; v){ for(int j=0;j&lt;10;j++) { cout&lt;&lt;v.at(j)&lt;&lt;\" \"; } cout&lt;&lt;endl;}int main(){ vector&lt;int&gt; v1; vector&lt;int&gt; v2; for(int i=0;i&lt;10;i++) { v1.push_back(i); } for(int j=0;j&lt;10;j++) { v2.push_back(j+1); } print(v1); print(v2); cout&lt;&lt;endl; v1.swap(v2); print(v1); print(v2); return 0;} vector 的预留空间reserve()当数据非常大的时候，可能需要开辟几次空间，那么我们直接预留出相应的空间即可 deque(双端数组) 容器首先需要加头文件 #include初始化构造基本与vector相同，dequed1;赋值操作与vector也相同容量的操作与vector相同，只是没有capacity,deque 的插入与删除 12345678push_back()//尾部添加push_front()//头部添加pop_back()//删除容器最后一个pop_front()//删除第一个元素insert(pos,n,ele)//在pos位置添加n个元素insert(pos,beg,end)//在pos后添加[beg,end)元素erase(beg,end)//删除[beg,end)的元素erase(pos)//删除pos位置的元素 deque 的数据存取d.at(i) d[i] d.front() d.back()deque 的排序sort(d.begin(),d.end()) 评委打分的案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;vector&gt;#include&lt;deque&gt;#include&lt;string&gt;#include&lt;algorithm&gt;class Person{public: string m_Name; int m_Res; Person(string name,int res) { this-&gt;m_Name=name; this-&gt;m_Res=res; }};int main(){ vector&lt;Person&gt;stu; string t=\"ABCDE\"; for(int i=0;i&lt;5;i++) { string name=\"选手：\"; name+=t[i]; int res=0; Person p(name,res); stu.push_back(p); } for(vector&lt;Person&gt;::iterator it=stu.begin();it!=stu.end();it++) { deque&lt;int&gt;tea; for(int j=0;j&lt;10;j++) { int res=rand()%41+60; tea.push_back(res); } sort(tea.begin(),tea.end()); tea.pop_back(); tea.pop_front(); int sum=0; for(deque&lt;int&gt;::iterator dit=tea.begin();dit!=tea.end();dit++) { sum+=*dit; } double avg=sum/tea.size(); it-&gt;m_Res=avg; cout&lt;&lt;it-&gt;m_Name&lt;&lt;\" 最后得分：\"&lt;&lt;it-&gt;m_Res&lt;&lt;endl; } return 0;} stack 容器栈是先进后出的数据结构 1234567891011121314151617#include&lt;stack&gt;int main(){ stack&lt;int&gt;s; s.push(10); s.push(20); s.push(30); s.push(40); while(!s.empty()) { cout&lt;&lt;s.top()&lt;&lt;\" \"; cout&lt;&lt;\"栈的大小为：\"&lt;&lt;s.size()&lt;&lt;endl; s.pop(); } return 0;} queue (队列) 容器队列是先进先出 常用命令与 stack 相似push popback()返回最后一个元素 front返回第一个元素 empty 是否为空，size大小 list 链表容器 构造与vector 等都相同 赋值和交换与vector相同 大小操作与vector 相同 插入与删除 push_back pop_back push_front pop_front insert erase 与 vector 都相同 数据存取 front返回第一个元素 back 返回最后一个元素 （不能用[]或at访问） 反转和排序 reverse链表的反转 sort链表的排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;list&gt;#include&lt;string&gt;class Person{public: Person(string name,int age,int high) { this-&gt;m_Name=name; this-&gt;m_Age=age; this-&gt;m_High=high; } string m_Name; int m_Age; int m_High;};bool compare(Person &amp;p8,Person &amp;p9){ if(p8.m_Age==p9.m_Age) { return p8.m_High&gt;p9.m_High; } else { return p8.m_Age&lt;p9.m_Age; }}int main(){ list&lt;Person&gt;p1; string name=\"学生\"; string add=\"ABCDE\"; int age=0; int high=0; for(int i=0;i&lt;5;i++) { name+=add; if(i&lt;3) { age=2; } else { age=i+1; } if(i&gt;=3) { high=22; } else { high=i+1; } Person p(name,age,high); p1.push_back(p); } Person p2(\"sfdf\",12,120); Person p3(\"afdf\",12,130); Person p4(\"vfdf\",12,20); Person p5(\"fdfdf\",22,200); Person p6(\"vfdf\",32,2004); p1.push_back(p2); p1.push_back(p3); p1.push_back(p4); p1.push_back(p5); p1.push_back(p6); p1.sort(compare); for(list&lt;Person&gt;::iterator it=p1.begin();it!=p1.end();it++) { cout&lt;&lt;it-&gt;m_Name&lt;&lt;\" \"&lt;&lt;it-&gt;m_Age&lt;&lt;\" \"&lt;&lt;it-&gt;m_High&lt;&lt;endl; } return 0;} set 和 multiset 容器 所有数据存入后，自动排序 set不允许有重复数 multiset 允许有重复数 在插数据时只有 insert 大小与交换 size swap 删除操作 erase(elem)删除elem erase(pos)删除pos位置的元素 查找和统计 find查找 count统计 pair 对组的创建不需要包含头文件格式为 pair&lt;type, type&gt; p(value1, value2)用 p.first p.second 来获取数据pair&lt;type, type&gt;；p=make_pair(value1,value2)改变 set 容器的排序规则 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// 1 存放内置的数据类型#include&lt;set&gt;void print(set&lt;int&gt;&amp;s1){ for(set&lt;int&gt;::iterator it=s1.begin();it!=s1.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; } cout&lt;&lt;endl;}class Compare{public: bool operator()(int v1,int v2)const { return v1&gt;v2; }};//下边方法行不通//void pai(set&lt;int&gt;&amp;s2)//{// for(set&lt;int&gt;::iterator it=s2.end();it!=s2.begin();it--)// {// cout&lt;&lt;*it&lt;&lt;\" \";// }// cout&lt;&lt;endl;//}int main(){ set&lt;int&gt; s; s.insert(1); s.insert(3); s.insert(2); s.insert(8); s.insert(4); s.insert(6); print(s); cout&lt;&lt;endl; set&lt;int,Compare&gt; s2;//用仿函数做了括号的重载 s2.insert(1); s2.insert(3); s2.insert(2); s2.insert(8); s2.insert(4); s2.insert(6); for(set&lt;int,Compare&gt;::iterator it=s2.begin();it!=s2.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; } return 0;}// 2 存放自定义的数据类型#include&lt;set&gt;#include&lt;string&gt;class Person{public: Person(string name,int age) { this-&gt;m_Name=name; this-&gt;m_Age=age; } string m_Name; int m_Age;};class Compare{public: bool operator()(const Person &amp;p1,const Person &amp;p2) { return p1.m_Age&gt;p2.m_Age; }};int main(){ set&lt;Person,Compare&gt;s1; Person p1(\"张三\",18); Person p2(\"李四\",58); Person p3(\"王五\",19); Person p4(\"赵六\",38); s1.insert(p1); s1.insert(p2); s1.insert(p3); s1.insert(p4); for(set&lt;Person,Compare&gt;::iterator it=s1.begin();it!=s1.end();it++) { cout&lt;&lt;it-&gt;m_Name&lt;&lt;\" \"&lt;&lt;it-&gt;m_Age&lt;&lt;endl; } cout&lt;&lt;endl; return 0;} map 与 multimap 容器 map中的元素为pair pair中第一个元素为key()键值 第二个为value实值 用于索引知道key 可以找到value map&lt;T1,T2&gt;m 赋值操作 m.insert(pair&lt;int,int&gt;(1,2)); 在输出时为 it-&gt;first it-&gt;second 大小和交换 size swap map 的插入与删除 1234567891011121314151617181920212223#include&lt;map&gt;void print(map&lt;int,int&gt;&amp;m){ for(map&lt;int,int&gt;::iterator it=m.begin();it!=m.end();it++) { cout&lt;&lt;it-&gt;first&lt;&lt;\" \"&lt;&lt;it-&gt;second&lt;&lt;endl; }}int main(){ map&lt;int,int&gt;m; m.insert(pair&lt;int,int&gt;(1,2));//m.insert(make_pair(1,2)) m.insert(pair&lt;int,int&gt;(2,3)); m.insert(pair&lt;int,int&gt;(3,4)); m.insert(pair&lt;int,int&gt;(4,5)); print(m); cout&lt;&lt;\"--------------------\"&lt;&lt;endl; m.erase(1);//按照key删除 print(m); cout&lt;&lt;m[4]&lt;&lt;endl;//可以用 4 找到 5 return 0;} map 的查找与统计find(key) count(key)map&lt;int,int&gt;::iterator pos=m.find(3)if(pos!=m.end())//说明找到了int num=m.cout(3); 12345678910111213141516171819202122#include&lt;map&gt;class Compair{public: bool operator()(const int k1,const int k2) { return k1&gt;k2; }};int main(){ map&lt;int,int,Compair&gt;m; m.insert(pair&lt;int,int&gt;(1,2)); m.insert(pair&lt;int,int&gt;(8,3)); m.insert(pair&lt;int,int&gt;(5,4)); m.insert(pair&lt;int,int&gt;(6,9)); for(map&lt;int,int,Compair&gt;::iterator it=m.begin();it!=m.end();it++) { cout&lt;&lt;it-&gt;first&lt;&lt;\" \"&lt;&lt;it-&gt;second&lt;&lt;endl; } return 0;} 函数对象的基本使用（仿函数） 重载函数调动操作符的类， 之前已经写过的operator() 函数对象在使用时，可以像普通函数一样调用 函数对象超越普通函数，有自己的状态 函数对象可以作为参数传递 之前做过 1234567891011121314class Add{public: int operator()(int a,int b) { return a+b; }};int main(){ Add add; cout&lt;&lt;add(1,5)&lt;&lt;endl; return 0;} 谓词这个之前做过，继承operator()的那个函数；返回 bool 类型的仿函数是谓词，一个参数是一元谓词，两个参数是二元谓词内建函数对象STL中内部包含的一些仿函数 需要加头文件 #include 123456template&lt;class T&gt; T plus&lt;T&gt; + template&lt;class T&gt; T minus&lt;T&gt; - template&lt;class T&gt; T multiplies&lt;T&gt; * template&lt;class T&gt; T divides&lt;T&gt; /template&lt;class T&gt; T modulus&lt;T&gt; %template&lt;class T&gt; T negate&lt;T&gt; 相反数 123456789#include&lt;functional&gt;int main(){ negate&lt;int&gt;n;//相反数 plus&lt;int&gt;m;//加法 cout&lt;&lt;m(10,20)&lt;&lt;endl; cout&lt;&lt;n(20)&lt;&lt;endl; return 0;} 关系仿函数 12345678910111213equal_to 等于not_equal_to 不等于greater 大于greater_equal 大于等于iess 小于 iess_equal 小于等于#include&lt;functional&gt;int main(){ greater&lt;int&gt;n; cout&lt;&lt;n(10,2)&lt;&lt;endl; return 0;} 逻辑仿函数 123456789logical_and 与 logical_or 或 logical_not 非#include&lt;functional&gt;int main(){ logical_and&lt;int&gt;n; cout&lt;&lt;n(5&gt;2,6&gt;9)&lt;&lt;endl; return 0;} 遍历算法 12345678910111213141516171819202122232425262728for_each(开始，结束，函数)#include&lt;vector&gt;#include&lt;algorithm&gt;void print(int a){ cout&lt;&lt;a&lt;&lt;\" \";}class Print2{public: void operator()(int a) { cout&lt;&lt;a&lt;&lt;\" \"; }};int main(){ vector&lt;int&gt;v1; v1.push_back(10); v1.push_back(20); v1.push_back(30); v1.push_back(40); for_each(v1.begin(),v1.end(),print);//正常函数 cout&lt;&lt;endl; for_each(v1.begin(),v1.end(),Print2());//仿函数 cout&lt;&lt;endl; return 0;} 容器的搬运算法 transform 1234567891011121314151617181920212223242526272829303132#include&lt;vector&gt;#include&lt;algorithm&gt;class Print{public: int operator()(int a) { return a; }};int print(int a){ return a;}int main(){ vector&lt;int&gt;v1; vector&lt;int&gt;v2; v1.push_back(10); v1.push_back(20); v1.push_back(30); v1.push_back(40); v2.resize(v1.size());//刚建立的v2要有内存 transform(v1.begin(),v1.end(),v2.begin(),print); for(vector&lt;int&gt;::iterator it=v2.begin();it!=v2.end();it++) {//也可以用for_each遍历元素 cout&lt;&lt;*it&lt;&lt;\" \"; } cout&lt;&lt;endl; return 0;} find 查找算法 find 查找元素 find_if 按照条件查找 adjacent_find 查找相邻的重复元素 binary 二分法查找元素 cout 统计元素个数 cout_if 按照条件查找元素的个数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201#include&lt;vector&gt;#include&lt;string&gt;#include&lt;algorithm&gt;// find(begin,end,仿函数) 内置的数据类型int main(){ vector&lt;int&gt;v1; v1.push_back(10); v1.push_back(20); v1.push_back(30); v1.push_back(40); vector&lt;int&gt;::iterator it=find(v1.begin(),v1.end(),220); if(*it==v1.end()) { cout&lt;&lt;\"没有找到\"&lt;&lt;endl; } else { cout&lt;&lt;\"找到了\"&lt;&lt;endl; } return 0;}// find 自定义的数据类型class Person{public: Person(string name,int age) { this-&gt;m_Name=name; this-&gt;m_Age=age; } bool operator==(const Person &amp;p) { if(this-&gt;m_Name==p.m_Name&amp;&amp;this-&gt;m_Age==p.m_Age) { return true; } else { return false; } } string m_Name; int m_Age;};int main(){ vector&lt;Person&gt;v2; Person p1(\"aa\",10); Person p2(\"bb\",20); Person p3(\"cc\",30); Person p4(\"dd\",40); v2.push_back(p1); v2.push_back(p2); v2.push_back(p3); v2.push_back(p4); Person pp(\"dd\",50); vector&lt;Person&gt;::iterator it=find(v2.begin(),v2.end(),pp); if(it==v2.end()) { cout&lt;&lt;\"没有找到\"&lt;&lt;endl; } else { cout&lt;&lt;\"找到了\"&lt;&lt;it-&gt;m_Name&lt;&lt;\" \"&lt;&lt;it-&gt;m_Age&lt;&lt;endl; } return 0;}//find_if(begin,end,仿函数) 的内置数据类型#include&lt;vector&gt;#include&lt;string&gt;#include&lt;algorithm&gt;class Findd{public: bool operator()(int a) { return a&gt;20; }};int main(){ vector&lt;int&gt;v1; v1.push_back(10); v1.push_back(20); v1.push_back(30); v1.push_back(40); for(vector&lt;int&gt;::iterator it=find_if(v1.begin(),v1.end(),Findd());it!=v1.end();it++) { if(it==v1.end()) { cout&lt;&lt;\"没有找到\"&lt;&lt;endl; } else { cout&lt;&lt;\"找到了\"&lt;&lt;*it&lt;&lt;endl; } } return 0;}//find_if 的自定义的数据类型#include&lt;vector&gt;#include&lt;string&gt;#include&lt;algorithm&gt;class Person{public: Person(string name,int age) { this-&gt;m_Name=name; this-&gt;m_Age=age; } string m_Name; int m_Age;};class Findd{public: bool operator()(const Person &amp;p) { return p.m_Age&gt;20; }};int main(){ vector&lt;Person&gt;v2; Person p1(\"aa\",10); Person p2(\"aa\",20); Person p3(\"cc\",30); Person p4(\"aa\",40); v2.push_back(p1); v2.push_back(p2); v2.push_back(p3); v2.push_back(p4); for(vector&lt;Person&gt;::iterator it=find_if(v2.begin(),v2.end(),Findd());it!=v2.end();it++) { if(it==v2.end()) { cout&lt;&lt;\"没有找到\"&lt;&lt;endl; } else { cout&lt;&lt;\"找到了\"&lt;&lt;it-&gt;m_Name&lt;&lt;\" \"&lt;&lt;it-&gt;m_Age&lt;&lt;endl; } } return 0;}//adjacent_find查找数据类型 查找相邻的重复出现的数据#include&lt;vector&gt;#include&lt;algorithm&gt;int main(){ vector&lt;int&gt; v1; v1.push_back(10); v1.push_back(20); v1.push_back(20); v1.push_back(40); v1.push_back(40); v1.push_back(40); vector&lt;int&gt;::iterator it=adjacent_find(v1.begin(),v1.end()); if(it==v1.end()) { cout&lt;&lt;\"没有重复的数\"&lt;&lt;endl; } else { cout&lt;&lt;*it&lt;&lt; \" 重复出现\"&lt;&lt;endl; } return 0;}//binary_search 查找指定的数据是否存在#include&lt;vector&gt;#include&lt;algorithm&gt;int main(){ vector&lt;int&gt; v1; v1.push_back(10); v1.push_back(20); v1.push_back(20); v1.push_back(40); v1.push_back(40); v1.push_back(40); bool it=binary_search(v1.begin(),v1.end(),200); if(it==false) { cout&lt;&lt;\"没有找到指定的数\"&lt;&lt;endl; } else { cout&lt;&lt; \" 找到指定的数\"&lt;&lt;endl; } return 0;} count 统计元素的个数cout_if (begin,end,谓词) 按条件统计元素个数 谓词：bool的仿函数 123456789101112131415#include&lt;vector&gt;#include&lt;algorithm&gt;int main(){ vector&lt;int&gt; v1; v1.push_back(10); v1.push_back(20); v1.push_back(20); v1.push_back(40); v1.push_back(40); v1.push_back(40); int it=count(v1.begin(),v1.end(),40); cout&lt;&lt;it&lt;&lt;endl; return 0;} 排序算法 sort 比较常见的排序算法 random_shuffle 指定范围内调整次序（可打乱） merge 容器元素合并，转存到另外一个容器 reverse(begin,end) 反转指定范围的元素 sort(begin,end,可不填) 不填是从小到大，加functional头文件填greater()就从大到小 random_shuffle(begin,end);merge(begin1,end1,begin2,end2,begin3) 都为有序序列，加完还是有序序列 1234567891011121314151617181920212223242526272829#include&lt;vector&gt;#include&lt;algorithm&gt;void print(vector&lt;int&gt;&amp;v){ for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; } cout&lt;&lt;endl;}int main(){ vector&lt;int&gt;v1; vector&lt;int&gt;v2; vector&lt;int&gt;v3; v1.push_back(10); v1.push_back(20); v1.push_back(30); v1.push_back(40); v2.push_back(20); v2.push_back(30); v2.push_back(40); v3.resize(v1.size()+v2.size()); merge(v1.begin(),v1.end(),v2.begin(),v2.end(),v3.begin()); print(v3); return 0;} 拷贝和替换算法copy 容器内指定的元素拷贝到另一个容器replace 将容器内旧元素换成新元素replace_if 将满足条件的元素换成新元素swap 互换容器内元素copy(begin,end,新容器)replace(begin,end,old,new) old 元素变成 new 元素replace_if(begin,end,谓词,new)swap(容器一,容器二)算数生成算法需要在头文件 numeric 进行accumulate(begin,end,0) 返回int 0为起始值 计算区间内容器元素的总和fill(begin,end,val)把区间内的元素生成想要的数据常用的集合算法集合必须为有序集合set_intersection 求两个容器的交集set_union 求两个容器的并集set_difference 求两个容器的差集set_intersection(beg1,end1,beg2,end2,新容器)set_union(beg1,end1,beg2,end2,新容器)set_difference(beg1,end1,beg2,end2,新容器) c++ 文件处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;iostream&gt;#include&lt;fstream&gt;//读写文件的头文件using namespace std;//文件的打开方式ios::in //为读文件而打开文件ios::out//为写文件而打开文件ios::ate//初始位置：文件尾ios::app//追加方式写文件ios::trunc//如果文件存在，先删除,重新创建新的ios::binary//二进制方式ios::in | ios::binary//二进制读文件(使用两个以上)//*************写文件的步骤***********int main(){ //1 包含头文件 //2 创建流对象 ofstream ofs; //3 指定打开方式 ofs.open(\"test.txt\",ios::out);//参数为文件路径 和 打开方式 //4 写内容 ofs&lt;&lt;\"姓名：张三\"&lt;&lt;endl; ofs&lt;&lt;\"性别：男 \"&lt;&lt;endl; ofs&lt;&lt;\"年龄：18\"&lt;&lt;endl; //5 关闭文件 ofs.close();}//*******************读文件的步骤************int main(){ //1 包含头文件 //2 创建流对象 ifstream ifs; //3 打开文件，判断是否打开成功 ifs.open(\"file.txt\",ios::in);//参数为文件路径 和 打开方式 if(!ifs.is_open()) { cout&lt;&lt;\"打开失败\"&lt;&lt;endl; return ; } //4 读数据 char buf[1024]={0}; // 第一种 while(ifs&gt;&gt;buf) // 第二种 while(ifs.getline(buf,sizeof(buf))) //第三种 string buf; while(getline(ifs,buf)) { cout&lt;&lt;buf&lt;&lt;endl; } //5 关闭文件 ifs.close();}//************做密码保护*********//************二进制的方式写文件***********class Person{public: char m_Name[64]; int m_Age; int m_keyword;};int main(){ ofstream ofs; ofs.open(\"person.txt\",ios::out|ios::binary); Person p1={\"张三\",18,61162151}; Person p2={\"李四\",19,65624521}; ofs.write((const char*)&amp;p1,sizeof(Person)); ofs.write((const char*)&amp;p2,sizeof(Person)); ofs.close(); return 0;}//************二进制的读文件************class Person{public: char m_Name[64]; int m_Age; int m_keyword;};int main(){ ifstream ifs; ifs.open(\"person.txt\",ios::in|ios::binary); if(!ifs.is_open()) { cout&lt;&lt;\"文件打开失败。\"&lt;&lt;endl; return ; } Person p1; Person p2; ifs.read((char*)&amp;p1,sizeof(Person)); ifs.read((char*)&amp;p2,sizeof(Person)); cout&lt;&lt;\"第一个人 姓名：\"&lt;&lt;p1.m_Name&lt;&lt;\" 年龄：\"&lt;&lt;p1.m_Age&lt;&lt;\" 密码: \"&lt;&lt;p1.m_keyword&lt;&lt;endl; cout&lt;&lt;\"第一个人 姓名：\"&lt;&lt;p2.m_Name&lt;&lt;\" 年龄：\"&lt;&lt;p2.m_Age&lt;&lt;\" 密码: \"&lt;&lt;p2.m_keyword&lt;&lt;endl; ifs.close(); //return 0;}","link":"/2019/12/03/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98c-%E6%95%99%E7%A8%8B%EF%BC%88%E6%80%BB%E7%BB%93%E6%9A%91%E5%81%87%E7%9A%84%E5%BF%83%E5%BE%97%EF%BC%89/"}],"tags":[{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"最优化算法","slug":"最优化算法","link":"/tags/%E6%9C%80%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线性表","slug":"线性表","link":"/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"排序算法","slug":"排序算法","link":"/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"职工管理系统","slug":"职工管理系统","link":"/tags/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"张量互补问题","slug":"张量互补问题","link":"/tags/%E5%BC%A0%E9%87%8F%E4%BA%92%E8%A1%A5%E9%97%AE%E9%A2%98/"},{"name":"边缘碰撞","slug":"边缘碰撞","link":"/tags/%E8%BE%B9%E7%BC%98%E7%A2%B0%E6%92%9E/"}],"categories":[{"name":"c++","slug":"c","link":"/categories/c/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"张量互补问题","slug":"张量互补问题","link":"/categories/%E5%BC%A0%E9%87%8F%E4%BA%92%E8%A1%A5%E9%97%AE%E9%A2%98/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"时间变化凸优化","slug":"时间变化凸优化","link":"/categories/%E6%97%B6%E9%97%B4%E5%8F%98%E5%8C%96%E5%87%B8%E4%BC%98%E5%8C%96/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"}]}